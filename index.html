// ========================================================================
// Configurações Globais Essenciais
// ========================================================================

// !!! IMPORTANTE: Substitua 'SEU_ID_DA_PLANILHA_AQUI' pelo ID REAL da sua Planilha Google !!!
var PLANILHA_ID = '1akGddFE_lrv9sGNalTYdgUhDfrxFLzsVSOVwD2fuPcc'; // <--- COLOQUE O ID DA SUA PLANILHA AQUI!
// !!! =================================================================================== !!!

var PASTA_IMAGENS_ID = '';     // ID da pasta no Drive para imagens (será configurado/obtido automaticamente)
var VERSAO_APP = '1.2.4';     // Versão atual do script (Incremented to reflect changes)

// Nomes EXATOS das abas da sua planilha (ajuste se necessário)
var NOME_PLANILHA_MANUTENCOES = 'Manutenções';
var NOME_PLANILHA_EQUIPAMENTOS = 'Equipamentos';
var NOME_PLANILHA_HISTORICO = 'Histórico';
var NOME_PLANILHA_CONFIGURACOES = 'Configurações';

// Constantes para Status de Manutenção (evita erros de digitação)
const STATUS_AGUARDANDO = "Aguardando Manutenção";
const STATUS_EM_MANUTENCAO = "Em Manutenção";
const STATUS_CONCLUIDO = "Manutenção Concluída";
const STATUS_DISPONIVEL = "Equipamento Disponível";

// Lista de origens permitidas para CORS
var ALLOW_ORIGINS = [
  'https://grupogps-mecanizada.github.io', // Seu frontend
  'http://127.0.0.1:5500', // Para testes locais
  'http://localhost:5500'  // Para testes locais
  // Adicione outros origins permitidos aqui, se necessário
];

// ========================================================================
// Função Centralizada de CORS
// ========================================================================

/**
 * Gera os cabeçalhos CORS apropriados com base na origem da requisição.
 * @param {object} e O objeto de evento do Apps Script (doGet/doPost).
 * @returns {object} Um objeto contendo os cabeçalhos CORS a serem aplicados.
 */
function handleCors(e) {
  var headers = {};
  var requestOrigin = null;
  try {
    // Tenta obter o origin do parâmetro (menos comum) ou dos cabeçalhos HTTP
    requestOrigin = (e && e.parameter && e.parameter.origin) ||
                    (e && e.headers && (e.headers['Origin'] || e.headers['origin'])) ||
                    (e && e.postData && e.postData.origin) || // Tenta do postData também
                    null; // Garante null se não encontrado
  } catch (error) {
    Logger.log("Erro ao obter origin da requisição: " + error);
  }

  // Define cabeçalhos CORS se a origem for permitida
  if (requestOrigin && ALLOW_ORIGINS.indexOf(requestOrigin) !== -1) {
      headers = {
          'Access-Control-Allow-Origin': requestOrigin, // Retorna a origem específica
          'Access-Control-Allow-Credentials': 'true', // Permite credenciais (cookies, autenticação)
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', // Métodos permitidos
          'Access-Control-Allow-Headers': 'Content-Type, Authorization' // Cabeçalhos permitidos (ajuste conforme sua necessidade)
      };
      // Logger.log("CORS Headers definidos para: " + requestOrigin); // Descomente para depurar CORS
  } else if (!requestOrigin) {
       // Se a origem for null (chamada direta, sem browser, como Postman sem header 'Origin'),
       // NÃO define cabeçalho Access-Control-Allow-Origin.
       // Deixar de definir é mais seguro do que permitir '*'.
       // Aplicações que precisam de credentials: 'true' NÃO podem usar '*'.
       Logger.log("Origem da requisição não detectada ou requisição não-navegador.");
  } else {
      Logger.log("Origin não permitido: " + requestOrigin);
      // Não define cabeçalhos, o navegador bloqueará a requisição.
      // O retorno será um objeto headers vazio.
  }
  return headers;
}


// ========================================================================
// Pontos de Entrada do Web App (doGet e doPost)
// ========================================================================

/**
 * Lida com requisições GET. Serve o HTML ou processa ações da API GET.
 * Incorpora o tratamento CORS centralizado e tratamento de preflight (OPTIONS).
 * @param {object} e Evento do Google Apps Script contendo parâmetros da requisição.
 * @returns {HtmlOutput|ContentService.TextOutput} Saída HTML ou JSON.
 */
function doGet(e) {
  // 1. Gera os cabeçalhos CORS aplicáveis à requisição
  var corsHeaders = handleCors(e);
  var requestOrigin = corsHeaders['Access-Control-Allow-Origin'] || (e && e.headers && (e.headers['Origin'] || e.headers['origin'])) || 'N/A'; // Para logs

  // 2. Tratamento ESSENCIAL de Preflight request (OPTIONS)
  // O navegador envia OPTIONS antes de GET/POST se houver headers customizados, CORS com credenciais, etc.
  if (e && e.requestMethod === 'OPTIONS') {
    Logger.log(`Recebido Preflight Request (OPTIONS) em doGet da origem: ${requestOrigin}`);
    // Retorna apenas os cabeçalhos CORS e status 204 (No Content) - o corpo é ignorado
    return ContentService.createTextOutput()
        .setMimeType(ContentService.MimeType.TEXT) // Conteúdo não importa
        .setHeaders(corsHeaders); // Aplica os cabeçalhos CORS calculados
  }

  // 3. Lógica principal do doGet (Servir HTML ou API GET)
  try {
    // 3.1. Servir a Interface HTML Principal (se não houver 'action')
    if (!e || !e.parameter || !e.parameter.action) {
      var template = HtmlService.createTemplateFromFile('index'); // Assume que você tem um index.html
      template.VERSAO_APP = VERSAO_APP; // Passa a versão para o HTML
      var htmlOutput = template.evaluate()
          .setTitle('Sistema de Manutenção v' + VERSAO_APP)
          .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL) // Permite incorporar em iframes (se necessário)
          .addMetaTag('viewport', 'width=device-width, initial-scale=1');
      // Não é padrão adicionar headers CORS a HtmlOutput, mas se necessário:
      // Object.keys(corsHeaders).forEach(key => htmlOutput.setHeader(key, corsHeaders[key]));
      return htmlOutput;
    }

    // 3.2. Processar Ações da API via GET (Leitura de Dados)
    var action = e.parameter.action;
    var result = {};
    Logger.log(`Ação GET Recebida: ${action} | Origem: ${requestOrigin} | Params: ${JSON.stringify(e.parameter)}`);

    // --- Executa a ação solicitada ---
    switch (action) {
        case "obterConfiguracoesIniciais": result = obterConfiguracoesIniciais(); break;
        case "obterEquipamentos": result = obterEquipamentos(); break;
        case "listarManutencoes": result = listarManutencoes(e.parameter.status, e.parameter.placa, e.parameter.limite); break;
        case "obterManutencao":
             if (!e.parameter.id) throw new Error("ID ausente para 'obterManutencao'");
             result = obterManutencao(e.parameter.id); break;
        case "obterDadosDashboard": result = obterDadosDashboard(); break;
        case "obterManutencoesPorPeriodo": result = obterManutencoesPorPeriodo(e.parameter.dias); break;
        case "gerarRelatorioTexto":
             if (!e.parameter.id) throw new Error("ID ausente para 'gerarRelatorioTexto'");
             result = gerarRelatorioManutencaoTexto(e.parameter.id); break;
        case "gerarPDFTextoBackend":
            if (!e.parameter.id) throw new Error("ID ausente para 'gerarPDFTextoBackend'");
            result = gerarPDFTextoBackend(e.parameter.id); break;
         case "gerarRelatorioAvancado":
            if (!e.parameter.id) throw new Error("ID ausente para 'gerarRelatorioAvancado'");
            result = gerarRelatorioAvancado(e.parameter.id, e.parameter.formato || 'pdf', {}); break;
        case "obterConfiguracoesGerais": result = obterConfiguracoesGerais(); break;
        case "obterHistoricoManutencao":
            if (!e.parameter.id) throw new Error("ID ausente para 'obterHistoricoManutencao'");
            result = obterHistoricoManutencao(e.parameter.id); break;
        case "ping": result = ping(); break;
        case "obterVersaoApp": result = obterVersaoApp(); break;
        default:
           result = { success: false, message: "Ação GET desconhecida: " + action };
    }

    // 4. Retorna o resultado como JSON com os cabeçalhos CORS
    return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON)
        .setHeaders(corsHeaders); // Aplica os cabeçalhos CORS calculados

  } catch (error) {
    // 5. Tratamento de Erro: Loga e retorna erro JSON com cabeçalhos CORS
    Logger.log(`Erro CRÍTICO em doGet: ${error.message}\nOrigem: ${requestOrigin}\nAção: ${e && e.parameter ? e.parameter.action : 'N/A'}\nStack: ${error.stack}`);
    return ContentService.createTextOutput(JSON.stringify({ success: false, message: "Erro interno no servidor (GET): " + error.message }))
        .setMimeType(ContentService.MimeType.JSON)
        .setHeaders(corsHeaders); // Aplica cabeçalhos CORS mesmo no erro
  }
}


/**
 * Lida com requisições POST. Usado para salvar dados, fazer uploads, etc.
 * Incorpora o tratamento CORS centralizado, tratamento de preflight (OPTIONS) e LockService.
 * @param {object} e Evento do Google Apps Script contendo dados da requisição POST.
 * @returns {ContentService.TextOutput} Saída JSON.
 */
function doPost(e) {
   // 1. Tenta adquirir Lock para evitar concorrência
   var lock = LockService.getScriptLock();
   var lockAcquired = lock.tryLock(25000); // Tenta por 25s

   // 2. Gera os cabeçalhos CORS aplicáveis (mesmo se o lock falhar, para a resposta de erro)
   var corsHeaders = handleCors(e);
   var requestOrigin = corsHeaders['Access-Control-Allow-Origin'] || (e && e.headers && (e.headers['Origin'] || e.headers['origin'])) || 'N/A'; // Para logs

   // 3. Se não conseguiu o Lock, retorna erro imediatamente
   if (!lockAcquired) {
      Logger.log(`Não foi possível obter o lock em doPost. Origem: ${requestOrigin}`);
      return ContentService.createTextOutput(JSON.stringify({ success: false, message: "Servidor ocupado, tente novamente em alguns instantes." }))
          .setMimeType(ContentService.MimeType.JSON)
          .setHeaders(corsHeaders); // Envia cabeçalhos CORS na resposta de erro de lock
   }

   // Variável para payload, definida fora do try para acesso no catch/finally
   var payload = null;

   // 4. Bloco principal com try...catch...finally para garantir liberação do lock
   try {
      // 4.1. Tratamento ESSENCIAL de Preflight request (OPTIONS) para POST
      // Ocorre ANTES de tentar ler o postData.contents
      if (e && e.requestMethod === 'OPTIONS') {
        Logger.log(`Recebido Preflight Request (OPTIONS) em doPost da origem: ${requestOrigin}`);
        // IMPORTANTE: Liberar o lock ANTES de retornar a resposta 204
        lock.releaseLock();
        lockAcquired = false; // Marca que o lock foi liberado
        return ContentService.createTextOutput()
            .setMimeType(ContentService.MimeType.TEXT) // Conteúdo não importa
            .setHeaders(corsHeaders); // Aplica os cabeçalhos CORS calculados
      }

      // 4.2. Processamento do Payload POST (APÓS tratar OPTIONS)
      if (!e || !e.postData || !e.postData.contents) {
           throw new Error("Requisição POST inválida ou sem dados (e.postData.contents ausente).");
      }
      try {
          payload = JSON.parse(e.postData.contents);
      } catch (jsonError) {
          Logger.log("Erro ao parsear JSON do POST: " + e.postData.contents);
          throw new Error("Erro ao decodificar dados da requisição (JSON inválido): " + jsonError.message);
      }
      if (!payload || !payload.action) {
          throw new Error("Parâmetro 'action' ausente no payload JSON do POST.");
      }

      var action = payload.action;
      var result = {};
      Logger.log(`Ação POST Recebida: ${action} | Origem: ${requestOrigin}`); // Log menos verboso, payload pode ser grande

      // 4.3. Executa a Ação Solicitada
      switch (action) {
        case "salvarManutencao":
          if (!payload.dados) throw new Error("Objeto 'dados' ausente no payload para 'salvarManutencao'");
          var dadosManut;
          if (typeof payload.dados === 'string') {
              try { dadosManut = JSON.parse(payload.dados); } catch (parseErr) { throw new Error("Erro ao parsear string 'dados' em salvarManutencao: " + parseErr.message); }
          } else if (typeof payload.dados === 'object' && payload.dados !== null) {
              dadosManut = payload.dados;
          } else {
              throw new Error("Formato inválido para 'dados' em salvarManutencao (esperado objeto ou string JSON).");
          }
          result = salvarManutencao(dadosManut);
          break;
        case "uploadImagem":
          if (!payload.id || !payload.imagem || !payload.tipo) throw new Error("Parâmetros insuficientes (id, imagem, tipo) para 'uploadImagem'");
          result = uploadImagem(payload.id, payload.imagem, payload.tipo, payload.idOriginalParaSubstituir);
          break;
        case "atualizarStatusManutencao":
           if (!payload.id || !payload.status) throw new Error("Parâmetros insuficientes (id, status) para 'atualizarStatusManutencao'");
           result = atualizarStatusManutencao(payload.id, payload.status);
           break;
        case "excluirManutencao":
           if (!payload.id) throw new Error("ID ausente para 'excluirManutencao'");
           result = excluirManutencao(payload.id);
           break;
         case "excluirImagem":
            if (!payload.idManutencao || !payload.idImagem || !payload.tipo) throw new Error("Parâmetros insuficientes (idManutencao, idImagem, tipo) para 'excluirImagem'");
            result = excluirImagem(payload.idManutencao, payload.idImagem, payload.tipo);
            break;
        case "salvarConfiguracao":
           if (!payload.chave) throw new Error("Chave ausente para 'salvarConfiguracao'");
           result = salvarConfiguracao(payload.chave, payload.valor !== undefined ? payload.valor : "");
           break;
        case "configurarGatilhoAutomatico":
           result = configurarGatilhoAutomatico();
           break;
        case "enviarEmailNotificacao":
           if (!payload.id || payload.destinatarios === undefined) throw new Error("Parâmetros insuficientes (id, destinatarios) para 'enviarEmailNotificacao'");
           var dest = [];
            if (typeof payload.destinatarios === 'string') {
               try { dest = JSON.parse(payload.destinatarios); if (!Array.isArray(dest)) throw new Error("'destinatarios' parseado não é array"); } catch (e) { throw new Error("Erro ao parsear 'destinatarios': " + e.message); }
            } else if (Array.isArray(payload.destinatarios)) {
                dest = payload.destinatarios;
            } else {
                throw new Error("Formato inválido para 'destinatarios' (esperado array ou string JSON).");
            }
           result = enviarEmailNotificacao(payload.id, dest, payload.tipo || 'atualizacao');
           break;
        case "integrarComPlanilhaTurnos":
           result = integrarComPlanilhaTurnos(payload.idPlanilha || null);
           break;
        default:
          result = { success: false, message: "Ação POST desconhecida: " + action };
      }

      // 4.4. Retorna o resultado JSON com cabeçalhos CORS
      return ContentService.createTextOutput(JSON.stringify(result))
          .setMimeType(ContentService.MimeType.JSON)
          .setHeaders(corsHeaders); // Aplica os cabeçalhos CORS calculados

   } catch (error) {
      // 5. Tratamento de Erro: Loga e retorna erro JSON com cabeçalhos CORS
      Logger.log(`Erro CRÍTICO em doPost: ${error.message}\nOrigem: ${requestOrigin}\nAção: ${payload ? payload.action : 'N/A'}\nStack: ${error.stack}`);
      return ContentService.createTextOutput(JSON.stringify({ success: false, message: "Erro interno no servidor (POST): " + error.message }))
          .setMimeType(ContentService.MimeType.JSON)
          .setHeaders(corsHeaders); // Aplica cabeçalhos CORS mesmo no erro
  } finally {
      // 6. Libera o Lock SEMPRE que ele tiver sido adquirido e não liberado antes
      if (lockAcquired) {
          lock.releaseLock();
          // Logger.log("Lock liberado no finally do doPost."); // Descomente para depurar lock
      }
  }
}

// ========================================================================
// Funções de Gerenciamento da Planilha e Drive (Estrutura e Configuração)
// [O restante do código permanece o mesmo do Gas.txt original]
// ... (funções obterPlanilha, criarAba*, configurarPastaImagens, ...)
// ... (funções obterConfiguracoesIniciais, obterLinhaManutencaoPorId, obterEquipamentos, ...)
// ... (funções salvarManutencao, excluirManutencao, atualizarStatusEquipamento, ...)
// ... (funções registrarHistorico, atualizarStatusManutencao, obterManutencao, ...)
// ... (funções listarManutencoes, obterDadosDashboard, obterManutencoesPorPeriodo, ...)
// ... (funções de upload/exclusão de imagem, ...)
// ... (funções de geração de relatório PDF/Excel/CSV, ...)
// ... (funções de notificação por e-mail, ...)
// ... (funções de integração e agendamento, ...)
// ... (funções de configuração, ...)
// ... (funções utilitárias gerarId, formatarData, ping)
// ========================================================================


// ========================================================================
// Funções de Gerenciamento da Planilha e Drive (Estrutura e Configuração)
// ========================================================================
function obterPlanilha() {
  try {
    var planilha = SpreadsheetApp.openById(PLANILHA_ID);
    const nomesAbas = [NOME_PLANILHA_MANUTENCOES, NOME_PLANILHA_EQUIPAMENTOS, NOME_PLANILHA_HISTORICO, NOME_PLANILHA_CONFIGURACOES];
    const funcoesCriacao = [criarAbaManutencoes, criarAbaEquipamentos, criarAbaHistorico, criarAbaConfiguracoes];

    nomesAbas.forEach((nome, index) => {
      if (!planilha.getSheetByName(nome)) {
        funcoesCriacao[index](planilha);
        Logger.log(`Aba '${nome}' criada.`);
        SpreadsheetApp.flush(); // Força a atualização para que a aba exista na próxima verificação
      }
    });

    // Configura a pasta de imagens APÓS garantir que a aba Configurações existe
    if (!PASTA_IMAGENS_ID) configurarPastaImagens(planilha); // Passa a planilha para evitar reabrir

    // Atualiza a versão na aba Configurações
    var abaConfig = planilha.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
    if (abaConfig) {
      try {
        const configData = abaConfig.getRange("A:A").getValues();
        let versaoRow = -1;
        for (let i = 0; i < configData.length; i++) {
          if (String(configData[i][0]).trim() === "VERSAO_SCRIPT") { // Comparação robusta
            versaoRow = i + 1;
            break;
          }
        }
        if (versaoRow > 0) {
          var versaoCell = abaConfig.getRange(versaoRow, 2);
          if (String(versaoCell.getValue()) !== String(VERSAO_APP)) { // Comparação como string
            versaoCell.setValue(VERSAO_APP);
            Logger.log("Versão atualizada para " + VERSAO_APP + " na planilha.");
          }
        } else {
          // Se a chave não existe, adiciona
           abaConfig.appendRow(["VERSAO_SCRIPT", VERSAO_APP]);
           Logger.log("Chave VERSAO_SCRIPT adicionada à planilha com valor " + VERSAO_APP);
        }
      } catch (e) {
        Logger.log("Erro ao verificar/atualizar versão na planilha: " + e);
      }
    }
    return planilha;
  } catch (e) {
    Logger.log('Erro CRÍTICO obterPlanilha: ' + e.message + '\nStack: ' + e.stack);
    throw new Error("Falha ao acessar/configurar planilha: " + e.message + ". Verifique o PLANILHA_ID e as permissões.");
  }
}


function criarAbaManutencoes(planilha) {
  var cabecalhos = ['ID', 'Data_Criacao', 'Placa', 'Modelo', 'Tipo_Equipamento', 'Status', 'Categoria_Problema', 'Urgencia', 'Descricao_Problema', 'Motivo_Outro', 'Checklist_Pre', 'Observacoes_Pre', 'Imagens_Pre', 'Data_Manutencao', 'Checklist_Pos', 'Observacoes_Pos', 'Imagens_Pos', 'Responsavel', 'Data_Atualizacao'];
  var aba = planilha.insertSheet(NOME_PLANILHA_MANUTENCOES);
  aba.setTabColor('#0F9D58'); // Verde
  var rangeCabecalho = aba.getRange(1, 1, 1, cabecalhos.length);
  rangeCabecalho.setValues([cabecalhos]).setFontWeight('bold').setBackground('#E8F0FE').setHorizontalAlignment('center').setVerticalAlignment('middle');
  aba.setFrozenRows(1);
  if (aba.getFilter() == null) rangeCabecalho.createFilter(); // Adiciona filtro se não existir
  var statusCol = cabecalhos.indexOf('Status') + 1;
  if (statusCol > 0) {
    var rule = SpreadsheetApp.newDataValidation().requireValueInList([STATUS_AGUARDANDO, STATUS_EM_MANUTENCAO, STATUS_CONCLUIDO, STATUS_DISPONIVEL], true).setAllowInvalid(false).build();
    aba.getRange(2, statusCol, aba.getMaxRows() - 1).setDataValidation(rule); // Aplica validação na coluna inteira abaixo do cabeçalho
  }
  // Formatar colunas de data
  const colunasData = ['Data_Criacao', 'Data_Manutencao', 'Data_Atualizacao'];
  colunasData.forEach(nomeColuna => {
    const colIndex = cabecalhos.indexOf(nomeColuna);
    if (colIndex !== -1) aba.getRange(2, colIndex + 1, aba.getMaxRows() - 1).setNumberFormat('dd/mm/yyyy hh:mm:ss');
  });
  try { aba.autoResizeColumns(1, cabecalhos.length); } catch(e) { Logger.log("Aviso: AutoResize falhou em Manutenções: " + e); } // Auto ajuste de colunas
  return aba;
}

function criarAbaEquipamentos(planilha) {
  var cabecalhos = ['Placa', 'Modelo', 'Tipo_Equipamento', 'Data_Cadastro', 'Status', 'Ultima_Manutencao'];
  var aba = planilha.insertSheet(NOME_PLANILHA_EQUIPAMENTOS);
  aba.setTabColor('#DB4437'); // Vermelho
  var rangeCabecalho = aba.getRange(1, 1, 1, cabecalhos.length);
  rangeCabecalho.setValues([cabecalhos]).setFontWeight('bold').setBackground('#E8F0FE').setHorizontalAlignment('center');
  aba.setFrozenRows(1);
  if (aba.getFilter() == null) rangeCabecalho.createFilter();
  // Adiciona dados de exemplo se a aba estiver vazia
  if (aba.getLastRow() < 2) {
    var equipamentosIniciais = [
      ['EGC-2989', 'Tratamento', 'C. Alta Pressão', new Date(), 'Disponível', ''],
      ['DSY-6474', 'Vácuo 8k', 'C. Auto Vácuo', new Date(), 'Disponível', '']
      // Adicione mais exemplos se necessário
    ];
    aba.getRange(2, 1, equipamentosIniciais.length, cabecalhos.length).setValues(equipamentosIniciais);
  }
   var statusCol = cabecalhos.indexOf('Status') + 1;
  if (statusCol > 0) {
    var rule = SpreadsheetApp.newDataValidation().requireValueInList(["Disponível", "Em Manutenção", "Aguardando Manutenção", "Desativado"], true).setAllowInvalid(false).build();
    aba.getRange(2, statusCol, aba.getMaxRows() - 1).setDataValidation(rule);
  }
   // Formatar colunas de data
  const colunasData = ['Data_Cadastro', 'Ultima_Manutencao'];
  colunasData.forEach(nomeColuna => {
    const colIndex = cabecalhos.indexOf(nomeColuna);
    if (colIndex !== -1) aba.getRange(2, colIndex + 1, aba.getMaxRows() - 1).setNumberFormat('dd/mm/yyyy'); // Formato só data
  });
  try { aba.autoResizeColumns(1, cabecalhos.length); } catch(e) { Logger.log("Aviso: AutoResize falhou em Equipamentos: " + e); }
  return aba;
}

function criarAbaHistorico(planilha) {
  var cabecalhos = ['ID_Manutencao', 'Data', 'Placa', 'Status_Anterior', 'Status_Novo', 'Responsavel', 'Observacao'];
  var aba = planilha.insertSheet(NOME_PLANILHA_HISTORICO);
  aba.setTabColor('#4285F4'); // Azul
  var rangeCabecalho = aba.getRange(1, 1, 1, cabecalhos.length);
  rangeCabecalho.setValues([cabecalhos]).setFontWeight('bold').setBackground('#E8F0FE').setHorizontalAlignment('center');
  aba.setFrozenRows(1);
  if (aba.getFilter() == null) rangeCabecalho.createFilter();
  var dataCol = cabecalhos.indexOf('Data') + 1;
  if (dataCol > 0) aba.getRange(2, dataCol, aba.getMaxRows() - 1).setNumberFormat('dd/mm/yyyy hh:mm:ss');
  try { aba.autoResizeColumns(1, cabecalhos.length); } catch(e) { Logger.log("Aviso: AutoResize falhou em Histórico: " + e); }
  return aba;
}

function criarAbaConfiguracoes(planilha) {
  var abaConfig = planilha.insertSheet(NOME_PLANILHA_CONFIGURACOES);
  abaConfig.setTabColor('#FF6D00'); // Laranja
  abaConfig.setFrozenRows(1);

  // Estilos
  const estiloTitulo = SpreadsheetApp.newTextStyle().setBold(true).setFontSize(11).build();
  const estiloChave = SpreadsheetApp.newTextStyle().setBold(true).build();
  const fundoTitulo = '#CFD8DC'; // Cinza azulado claro
  const fundoChave = '#ECEFF1'; // Cinza bem claro
  const fundoValor = '#FAFAFA'; // Quase branco
  const bordaStyle = SpreadsheetApp.BorderStyle.SOLID_MEDIUM;
  const bordaColor = '#B0BEC5'; // Cinza médio

  // Limpar formatação e conteúdo existentes (caso seja recriação)
  abaConfig.clearFormats();
  abaConfig.clearContents();

  // --- Seção de Informações do Sistema ---
  abaConfig.getRange('A1:B1').merge().setValue('INFORMAÇÕES DO SISTEMA').setTextStyle(estiloTitulo).setBackground(fundoTitulo).setHorizontalAlignment('center');
  const infoSistema = [
    ['ID_PLANILHA', PLANILHA_ID],
    ['DATA_CRIACAO_SCRIPT', new Date()],
    ['VERSAO_SCRIPT', VERSAO_APP],
    ['PASTA_IMAGENS', ''] // Será preenchido por configurarPastaImagens
  ];
  const rangeInfo = abaConfig.getRange(2, 1, infoSistema.length, 2);
  rangeInfo.setValues(infoSistema)
           .setBorder(true, true, true, true, true, true, bordaColor, bordaStyle);
  // Estilo Chave/Valor
  abaConfig.getRange(2, 1, infoSistema.length, 1).setTextStyle(estiloChave).setBackground(fundoChave); // Coluna A (Chaves)
  abaConfig.getRange(2, 2, infoSistema.length, 1).setBackground(fundoValor); // Coluna B (Valores)
  // Formatação específica de valores
  abaConfig.getRange('B2').setNumberFormat('@'); // ID Planilha como texto
  abaConfig.getRange('B3').setNumberFormat('dd/mm/yyyy hh:mm'); // Data Criação
  abaConfig.getRange('B4').setNumberFormat('@'); // Versão como texto
  abaConfig.getRange('B5').setNumberFormat('@'); // ID Pasta como texto

  // --- Seção de Configurações Editáveis ---
  const linhaInicioConfigs = rangeInfo.getLastRow() + 2; // Deixa uma linha em branco
  abaConfig.getRange(linhaInicioConfigs, 1, 1, 2).merge().setValue('CONFIGURAÇÕES EDITÁVEIS (Listas Verticais na Coluna A)').setTextStyle(estiloTitulo).setBackground(fundoTitulo).setHorizontalAlignment('center');

  const cabecalhosConfig = [
      "CATEGORIAS DE PROBLEMAS",
      "TIPOS DE EQUIPAMENTOS",
      "NÍVEIS DE URGÊNCIA",
      "ITENS DO CHECKLIST",
      "EMAILS_NOTIFICACAO", // Configuração Simples (Valor na Coluna B)
      "ID_PLANILHA_TURNOS", // Configuração Simples (Valor na Coluna B)
      "INTEGRACAO_AUTOMATICA" // Configuração Simples (Valor na Coluna B)
  ];

  const dadosIniciais = {
      "CATEGORIAS DE PROBLEMAS": ["Problema Mecânico", "Problema Elétrico", "Vazamento", "Outro"],
      "TIPOS DE EQUIPAMENTOS": ["Caminhão Auto Vácuo", "Caminhão Alta Pressão", "Aspirador de Pó Industrial", "Bomba Submersível"],
      "NÍVEIS DE URGÊNCIA": ["Baixa", "Média", "Alta"],
      "ITENS DO CHECKLIST": ["Nível Óleo Motor", "Nível Água Radiador", "Condição Pneus", "Luzes/Sinalização", "Vazamentos Visíveis", "Limpeza Cabine/Equipamento"],
      "EMAILS_NOTIFICACAO": "exemplo1@dominio.com; exemplo2@dominio.com",
      "ID_PLANILHA_TURNOS": "",
      "INTEGRACAO_AUTOMATICA": "NAO"
  };

  let linhaAtual = linhaInicioConfigs + 1;

  cabecalhosConfig.forEach(cabecalho => {
      abaConfig.getRange(linhaAtual, 1).setValue(cabecalho).setTextStyle(estiloChave).setBackground(fundoChave)
               .setBorder(true,true,true,true,null,true,bordaColor,bordaStyle); // Borda superior, esquerda, inferior, direita

      // Verifica se é uma configuração de lista ou simples
      if (["EMAILS_NOTIFICACAO", "ID_PLANILHA_TURNOS", "INTEGRACAO_AUTOMATICA"].includes(cabecalho)) {
          // Configuração Simples: valor na coluna B
          let valorDefault = dadosIniciais[cabecalho] || '';
          abaConfig.getRange(linhaAtual, 2).setValue(valorDefault).setBackground(fundoValor).setWrap(true)
                   .setBorder(true,true,true,true,null,true,bordaColor,bordaStyle);
          linhaAtual++; // Avança para a próxima linha de configuração
      } else {
          // Configuração de Lista: valores na coluna A abaixo do cabeçalho
          abaConfig.getRange(linhaAtual, 2).setValue("").setBackground(fundoValor) // Coluna B vazia para listas
                   .setBorder(true,true,true,true,null,true,bordaColor,bordaStyle);
          linhaAtual++; // Pula linha do cabeçalho

          const itensLista = dadosIniciais[cabecalho] || [];
          if (itensLista.length > 0) {
              const rangeItens = abaConfig.getRange(linhaAtual, 1, itensLista.length, 1);
              rangeItens.setValues(itensLista.map(item => [item])) // Precisa ser array de arrays
                        .setFontStyle('italic').setForeground('#555') // Estilo para itens
                        .setBorder(null, true, null, true, null, true, bordaColor, SpreadsheetApp.BorderStyle.SOLID); // Bordas laterais finas
              // Coluna B correspondente vazia e com borda
               abaConfig.getRange(linhaAtual, 2, itensLista.length, 1).setBackground(fundoValor)
                         .setBorder(null, true, null, true, null, true, bordaColor, SpreadsheetApp.BorderStyle.SOLID);
              linhaAtual += itensLista.length;
          }
          // Linha em branco após a lista (opcional, para visualização)
          // abaConfig.getRange(linhaAtual, 1, 1, 2).setBorder(true, true, true, true, null, true, bordaColor, bordaStyle);
          // linhaAtual++;
      }

      // Adiciona uma linha divisória visual entre as configurações
      abaConfig.getRange(linhaAtual, 1, 1, 2)
               .setBorder(true, null, null, null, null, null, bordaColor, SpreadsheetApp.BorderStyle.SOLID_THICK); // Borda superior grossa
      // Não incrementa linhaAtual aqui, a próxima config sobrescreve essa borda com a sua própria borda completa
  });


  // Validação específica para INTEGRAÇÃO_AUTOMATICA
  const integracaoRowIndex = cabecalhosConfig.indexOf('INTEGRACAO_AUTOMATICA');
  if (integracaoRowIndex !== -1) {
     // Encontra a linha correta baseada na estrutura
     let linhaInt = linhaInicioConfigs + 1;
     for(let i = 0; i < integracaoRowIndex; i++) {
         const cabAtual = cabecalhosConfig[i];
         if (["EMAILS_NOTIFICACAO", "ID_PLANILHA_TURNOS", "INTEGRACAO_AUTOMATICA"].includes(cabAtual)) {
             linhaInt++; // Pula linha da config simples
         } else {
             // Pula cabeçalho da lista + número de itens
             linhaInt += 1 + (dadosIniciais[cabAtual] || []).length;
         }
     }

     // Verifica se a linha calculada é válida
     if (linhaInt <= abaConfig.getMaxRows()) {
         const cellIntegracao = abaConfig.getRange(linhaInt, 2);
         const ruleIntegracao = SpreadsheetApp.newDataValidation().requireValueInList(['SIM', 'NAO'], true).setAllowInvalid(false).build();
         cellIntegracao.setDataValidation(ruleIntegracao);
         Logger.log("Validação SIM/NAO aplicada na célula: " + cellIntegracao.getA1Notation());
     } else {
          Logger.log(`AVISO: Linha calculada (${linhaInt}) para INTEGRAÇÃO_AUTOMATICA excede o limite da aba.`);
     }
  } else {
      Logger.log("AVISO: Chave INTEGRAÇÃO_AUTOMATICA não encontrada para aplicar validação.");
  }

  // Ajustes finais e proteção
  abaConfig.setColumnWidth(1, 250); // Largura coluna Chave/Itens
  abaConfig.setColumnWidth(2, 450); // Largura coluna Valor
  try { abaConfig.autoResizeRows(1, abaConfig.getLastRow()); } catch(e) { Logger.log("Aviso: AutoResizeRows falhou em Configurações: " + e); }

  // Protege a estrutura, mas permite editar os valores
  var protection = abaConfig.protect().setDescription('Proteção Configs Estrutura');
  // Define o range desprotegido para TODOS os valores na coluna B e itens de lista na coluna A
  const ultimoDado = abaConfig.getLastRow();
  let rangesDesprotegidos = [];

  // Desprotege valores na coluna B (começando da linha 2)
  if (ultimoDado >= 2) {
    rangesDesprotegidos.push(abaConfig.getRange(2, 2, ultimoDado - 1, 1));
  }


  // Desprotege itens de lista na coluna A
  linhaAtual = linhaInicioConfigs + 1;
  cabecalhosConfig.forEach(cabecalho => {
      if (!["EMAILS_NOTIFICACAO", "ID_PLANILHA_TURNOS", "INTEGRACAO_AUTOMATICA"].includes(cabecalho)) {
          linhaAtual++; // Pula cabeçalho
          const itensLista = dadosIniciais[cabecalho] || [];
          if (itensLista.length > 0) {
               if (linhaAtual <= ultimoDado && linhaAtual + itensLista.length - 1 <= ultimoDado) {
                  rangesDesprotegidos.push(abaConfig.getRange(linhaAtual, 1, itensLista.length, 1));
               }
              linhaAtual += itensLista.length;
          }
      } else {
          linhaAtual++; // Pula linha da config simples
      }
      // Pula linha divisória (não precisa desproteger)
  });


  if (rangesDesprotegidos.length > 0) {
      // Filtra ranges inválidos antes de aplicar (embora as verificações acima devam prevenir)
      rangesDesprotegidos = rangesDesprotegidos.filter(r => r.getRow() <= abaConfig.getMaxRows() && r.getLastRow() <= abaConfig.getMaxRows());
      if (rangesDesprotegidos.length > 0) {
        protection.setUnprotectedRanges(rangesDesprotegidos);
        Logger.log("Proteção aplicada com ranges desprotegidos.");
      } else {
         Logger.log("Nenhum range desprotegido válido definido após filtro.");
      }
  } else {
       Logger.log("Nenhum range desprotegido definido.");
  }
   // Adiciona editores (opcional - adicione usuários específicos ou deixe aberto para quem tem acesso à planilha)
   // protection.addEditor(Session.getEffectiveUser());
   // protection.addEditor('outro.email@dominio.com');
   // Se quiser que qualquer pessoa com acesso de edição possa editar os valores:
    try {
        protection.removeEditors(protection.getEditors());
        if (protection.canDomainEdit()) {
            protection.setDomainEdit(true); // Permite edição por qualquer pessoa no domínio (se aplicável)
        }
    } catch (permErr) {
        Logger.log("Aviso: Não foi possível modificar editores da proteção. Permissões podem ser limitadas. " + permErr);
    }


  return abaConfig;
}


function configurarPastaImagens(planilhaAberta = null) {
  try {
    // Reutiliza a planilha se já estiver aberta, senão abre
    var planilha = planilhaAberta || SpreadsheetApp.openById(PLANILHA_ID);
    var abaConfig = planilha.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
    var pastaIdCell = null;
    var pastaId = null;
    var configRowIndex = -1;

    if (abaConfig) {
      // Leitura mais segura pegando apenas até a última linha com conteúdo
      const lastRow = abaConfig.getLastRow();
      const rangeData = lastRow >= 1 ? abaConfig.getRange("A1:B" + lastRow).getValues() : [];
      // const configData = abaConfig.getRange("A1:A" + abaConfig.getLastRow()).getValues(); // Ler só até a última linha
      for (let i = 0; i < rangeData.length; i++) {
        if (String(rangeData[i][0]).trim() === "PASTA_IMAGENS") { // Comparação robusta
          configRowIndex = i;
          pastaIdCell = abaConfig.getRange(i + 1, 2);
          pastaId = pastaIdCell.getValue();
          Logger.log(`Chave PASTA_IMAGENS encontrada na linha ${i+1}. ID atual: ${pastaId}`);
          break;
        }
      }
      // Se a chave não existe, adiciona no final
      if (configRowIndex === -1) {
        // Verifica se a última linha está realmente vazia antes de usar appendRow
        if(lastRow === 0 || abaConfig.getRange(lastRow, 1).getValue() !== "" || abaConfig.getRange(lastRow, 2).getValue() !== "") {
             abaConfig.appendRow(["PASTA_IMAGENS", ""]);
        } else {
             // Usa a última linha se estiver vazia
             abaConfig.getRange(lastRow, 1).setValue("PASTA_IMAGENS");
        }
        pastaIdCell = abaConfig.getRange(abaConfig.getLastRow(), 2); // Pega a célula correta após adicionar/modificar
        Logger.log("Chave PASTA_IMAGENS adicionada/definida na linha " + abaConfig.getLastRow());
      }
    } else {
        Logger.log(`Aba '${NOME_PLANILHA_CONFIGURACOES}' não encontrada durante config da pasta.`);
        // Tenta criar a aba se ela não existe (embora obterPlanilha já devesse ter feito isso)
        criarAbaConfiguracoes(planilha);
        SpreadsheetApp.flush();
        abaConfig = planilha.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
        if(!abaConfig) throw new Error(`Falha ao criar/encontrar a aba ${NOME_PLANILHA_CONFIGURACOES}`);
        // Tenta encontrar/adicionar a chave novamente
        abaConfig.appendRow(["PASTA_IMAGENS", ""]);
        pastaIdCell = abaConfig.getRange(abaConfig.getLastRow(), 2);
         Logger.log("Chave PASTA_IMAGENS adicionada após recriação da aba.");
    }

    var nomePasta = "Sistema de Manutenção - Imagens"; // Nome padrão da pasta no Drive

    // 1. Verifica se o ID na planilha é válido
    if (pastaId && typeof pastaId === 'string' && pastaId.trim() !== '') {
      try {
        var pastaExistente = DriveApp.getFolderById(pastaId);
        PASTA_IMAGENS_ID = pastaId; // Confirma o ID global
        Logger.log("Usando pasta existente configurada na planilha: ID " + PASTA_IMAGENS_ID + ", Nome: " + pastaExistente.getName());
        return { success: true, pastaId: PASTA_IMAGENS_ID };
      } catch (e) {
        Logger.log(`ID da pasta na planilha (${pastaId}) é inválido ou inacessível: ${e.message}. Procurando/Criando pasta...`);
        pastaId = null; // Invalida o ID para procurar/criar
        if(pastaIdCell) {
            try { pastaIdCell.setValue(''); } catch(cellErr) { Logger.log("Erro ao limpar célula da pasta: " + cellErr);}
        }
      }
    }

    // 2. Se não há ID válido na planilha, procura por nome
    var pasta;
    var pastasExistentes = DriveApp.getFoldersByName(nomePasta);
    if (pastasExistentes.hasNext()) {
      pasta = pastasExistentes.next();
      // Se houver múltiplas pastas com o mesmo nome, pega a primeira encontrada.
      if (pastasExistentes.hasNext()) {
         Logger.log("AVISO: Múltiplas pastas encontradas com o nome '" + nomePasta + "'. Usando a primeira encontrada (ID: " + pasta.getId() + ").");
      }
      PASTA_IMAGENS_ID = pasta.getId();
      Logger.log("Pasta encontrada pelo nome: '" + nomePasta + "', ID: " + PASTA_IMAGENS_ID);
    } else {
      // 3. Se não encontrou por nome, cria a pasta
      pasta = DriveApp.createFolder(nomePasta);
      PASTA_IMAGENS_ID = pasta.getId();
      Logger.log("Pasta criada: '" + nomePasta + "', ID: " + PASTA_IMAGENS_ID);
    }

    // Atualiza o ID na planilha
    if (pastaIdCell) {
        try {
            pastaIdCell.setValue(PASTA_IMAGENS_ID);
            Logger.log("ID da pasta ("+PASTA_IMAGENS_ID+") salvo na planilha.");
        } catch(cellErr) {
             Logger.log(`ERRO: Não foi possível salvar o ID da pasta na célula ${pastaIdCell.getA1Notation()}: ${cellErr}`);
        }
    } else {
         Logger.log("ERRO: Não foi possível encontrar a célula para salvar o ID da pasta na aba Configurações.");
    }

    return { success: true, pastaId: PASTA_IMAGENS_ID };

  } catch (e) {
    Logger.log("Erro CRÍTICO ao configurar pasta de imagens: " + e.message + "\nStack: " + e.stack);
    // Não define PASTA_IMAGENS_ID global em caso de erro
    // Retorna erro para que as funções dependentes saibam que falhou
    return { success: false, message: "Falha ao configurar pasta de imagens: " + e.message };
  }
}

// ========================================================================
// Funções da API (Leitura e Escrita de Dados)
// ========================================================================

/**
 * Obtém listas de configurações iniciais lendo blocos específicos da aba 'Configurações'.
 * @returns {{success: boolean, tiposEquipamentos?: Array<string>, categoriasProblemas?: Array<string>, niveisUrgencia?: Array<string>, checklistItens?: Array<string>, message?: string}}
 */
function obterConfiguracoesIniciais() {
  try {
    const planilha = obterPlanilha(); // Garante que as abas existem
    const abaConfig = planilha.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
    if (!abaConfig) {
       // Tenta criar de novo se falhou antes, embora obterPlanilha devesse tratar isso
       criarAbaConfiguracoes(planilha);
       SpreadsheetApp.flush();
       const abaConfigNova = planilha.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
       if (!abaConfigNova) throw new Error(`Aba '${NOME_PLANILHA_CONFIGURACOES}' não encontrada e não pôde ser criada.`);
       return obterConfiguracoesIniciais(); // Tenta de novo após criar
    }


    const dados = abaConfig.getDataRange().getValues();
    const numLinhas = dados.length;

    // Nomes EXATOS dos cabeçalhos como estão na planilha na Coluna A
    const cabecalhosListas = {
      categorias: "CATEGORIAS DE PROBLEMAS",
      tipos: "TIPOS DE EQUIPAMENTOS",
      urgencias: "NÍVEIS DE URGÊNCIA",
      checklist: "ITENS DO CHECKLIST"
    };

    const listasResult = {
        categoriasProblemas: [],
        tiposEquipamentos: [],
        niveisUrgencia: [],
        checklistItens: []
    };

    let cabecalhoAtual = null; // Para saber qual lista estamos preenchendo
    let keyCabecalhoAtual = null; // Armazena a chave ('categorias', 'tipos', etc.)

    for (let i = 0; i < numLinhas; i++) {
        const chaveColunaA = String(dados[i][0]).trim();
        // const valorColunaB = dados[i][1]; // Não usado diretamente aqui

        let isCabecalhoDeLista = false;
        // Verifica se a chave atual é um dos cabeçalhos de lista definidos
        for (const key in cabecalhosListas) {
            if (chaveColunaA.toUpperCase() === cabecalhosListas[key].toUpperCase()) {
                cabecalhoAtual = cabecalhosListas[key]; // Armazena o nome do cabeçalho
                keyCabecalhoAtual = key;               // Armazena a chave interna ('categorias', etc.)
                isCabecalhoDeLista = true;
                // Logger.log(`Encontrado cabeçalho de lista: ${cabecalhoAtual} (Linha ${i+1})`);
                break;
            }
        }

        // Se NÃO é um cabeçalho E estamos atualmente lendo uma lista (cabecalhoAtual não é null) E a chave não é vazia
        if (!isCabecalhoDeLista && cabecalhoAtual && chaveColunaA !== "") {
            // Adiciona o item (chaveColunaA) à lista correta em listasResult
             switch(keyCabecalhoAtual) {
                 case 'categorias': listasResult.categoriasProblemas.push(chaveColunaA); break;
                 case 'tipos': listasResult.tiposEquipamentos.push(chaveColunaA); break;
                 case 'urgencias': listasResult.niveisUrgencia.push(chaveColunaA); break;
                 case 'checklist': listasResult.checklistItens.push(chaveColunaA); break;
             }
             // Logger.log(`Adicionado item '${chaveColunaA}' à lista ${keyCabecalhoAtual}`);
        }
        // Se a linha atual é um novo cabeçalho de lista OU a chave é vazia,
        // significa que a lista anterior (se houver) terminou.
        else if (isCabecalhoDeLista || chaveColunaA === "") {
            // Logger.log(`Fim da lista anterior ou início de nova seção (Linha ${i+1}). Chave: '${chaveColunaA}', É Cabeçalho: ${isCabecalhoDeLista}`);
             // Se não for um novo cabeçalho de lista (ou seja, linha vazia ou outro tipo de chave),
             // reseta os marcadores de lista atual.
             if (!isCabecalhoDeLista) {
                cabecalhoAtual = null;
                keyCabecalhoAtual = null;
             }
             // Se for um novo cabeçalho de lista, os marcadores já foram atualizados no loop 'for (const key in cabecalhosListas)'
        }
    }


    // Logar para depuração
    // Logger.log("CATEGORIAS encontradas: " + JSON.stringify(listasResult.categoriasProblemas));
    // Logger.log("TIPOS encontrados: " + JSON.stringify(listasResult.tiposEquipamentos));
    // Logger.log("URGÊNCIAS encontradas: " + JSON.stringify(listasResult.niveisUrgencia));
    // Logger.log("CHECKLIST encontrados: " + JSON.stringify(listasResult.checklistItens));

    if (listasResult.categoriasProblemas.length === 0) Logger.log(`AVISO: Nenhuma '${cabecalhosListas.categorias}' encontrada na coluna A abaixo do cabeçalho.`);
    if (listasResult.tiposEquipamentos.length === 0) Logger.log(`AVISO: Nenhum '${cabecalhosListas.tipos}' encontrado na coluna A abaixo do cabeçalho.`);
    if (listasResult.niveisUrgencia.length === 0) Logger.log(`AVISO: Nenhum '${cabecalhosListas.urgencias}' encontrado na coluna A abaixo do cabeçalho.`);
    if (listasResult.checklistItens.length === 0) Logger.log(`AVISO: Nenhum '${cabecalhosListas.checklist}' encontrado na coluna A abaixo do cabeçalho.`);

    return {
      success: true,
      tiposEquipamentos: listasResult.tiposEquipamentos,
      categoriasProblemas: listasResult.categoriasProblemas,
      niveisUrgencia: listasResult.niveisUrgencia,
      checklistItens: listasResult.checklistItens
    };
  } catch (e) {
    Logger.log("Erro CRÍTICO obterConfiguracoesIniciais: " + e.message + "\nStack: " + e.stack);
    return {
      success: false,
      message: "Erro ao ler configurações iniciais: " + e.message,
      tiposEquipamentos: [],
      categoriasProblemas: [],
      niveisUrgencia: [],
      checklistItens: [] // Retorna arrays vazios em caso de erro
    };
  }
}


/**
 * Obtém a linha e dados de uma manutenção a partir do ID
 * @param {Sheet} aba A aba de manutenções
 * @param {Array<string>} cabecalhos Lista de nomes das colunas
 * @param {string} id ID da manutenção a ser encontrada
 * @returns {Object|null} Objeto com linha e dados ou null se não encontrada
 */
function obterLinhaManutencaoPorId(aba, cabecalhos, id) {
  try {
    if (!aba || !cabecalhos || !id) {
        Logger.log("obterLinhaManutencaoPorId: Parâmetros inválidos.");
        return null;
    }

    const idCol = cabecalhos.indexOf('ID');
    if (idCol === -1) {
        Logger.log("obterLinhaManutencaoPorId: Coluna 'ID' não encontrada nos cabeçalhos.");
        return null; // Coluna ID é essencial
    }

    // Otimização: Ler apenas a coluna ID se a aba for muito grande?
    // Por enquanto, lê tudo para ter os dados completos.
    const dados = aba.getDataRange().getValues();

    // Começa do 1 para pular o cabeçalho
    for (let i = 1; i < dados.length; i++) {
      // Comparação robusta, convertendo ambos para string e trim()
      if (String(dados[i][idCol]).trim() === String(id).trim()) {
        const dadosObj = {};
        // Mapeia os dados da linha encontrada para um objeto usando os cabeçalhos
        for (let j = 0; j < cabecalhos.length; j++) {
          // Ignora colunas sem cabeçalho definido
          if (cabecalhos[j]) {
            dadosObj[cabecalhos[j]] = dados[i][j];
          }
        }
        // Retorna o número da linha (base 1) e o objeto com os dados
        return { linha: i + 1, dadosLinha: dadosObj };
      }
    }

    // Se o loop terminar sem encontrar
    // Logger.log(`obterLinhaManutencaoPorId: ID '${id}' não encontrado.`); // Log muito frequente
    return null;
  } catch (e) {
    Logger.log(`Erro em obterLinhaManutencaoPorId para ID ${id}: ${e.message}\n${e.stack}`);
    return null; // Retorna null em caso de erro inesperado
  }
}


/** Obtém a lista de equipamentos cadastrados. */
function obterEquipamentos() {
   try {
     var planilha = obterPlanilha();
     var abaEquipamentos = planilha.getSheetByName(NOME_PLANILHA_EQUIPAMENTOS);
     if (!abaEquipamentos) return { success: false, message: `Aba '${NOME_PLANILHA_EQUIPAMENTOS}' não encontrada.` };

     var dados = abaEquipamentos.getDataRange().getValues();
     if (dados.length <= 1) return { success: true, equipamentos: [] }; // Nenhnum equipamento cadastrado

     var cabecalhos = dados[0].map(h => String(h).trim());
     var equipamentos = [];

     // Verifica se colunas essenciais existem
     const cabecalhosObrigatorios = ['Placa', 'Tipo_Equipamento', 'Status']; // Adicionado Status como essencial
     for(let header of cabecalhosObrigatorios) {
       if(cabecalhos.indexOf(header) === -1) {
         return { success: false, message: `Coluna obrigatória '${header}' não encontrada na aba '${NOME_PLANILHA_EQUIPAMENTOS}'.` };
       }
     }

     // Itera pelas linhas de dados (começando da segunda linha)
     for (var i = 1; i < dados.length; i++) {
       var equip = {};
       let temPlacaOuTipo = false; // Flag para evitar adicionar linhas completamente vazias
       let linhaValida = false; // Flag para verificar se a linha tem dados minimamente válidos

       for (var j = 0; j < cabecalhos.length; j++) {
         var header = cabecalhos[j];
         if (!header) continue; // Pula colunas sem cabeçalho

         var valor = dados[i][j];

         // Tratamento especial para datas
         if ((header === 'Data_Cadastro' || header === 'Ultima_Manutencao') &&
             valor instanceof Date && !isNaN(valor.getTime())) {
           // Formata a data como ISO string para consistência com outras partes do código
           valor = valor.toISOString();
         } else {
           // Converte outros valores para string, tratando nulos/undefined
           valor = valor !== undefined && valor !== null ? String(valor) : "";
         }

         equip[header] = valor;

         // Verifica se a linha tem pelo menos Placa ou Tipo preenchido e não vazio
         if((header === 'Placa' || header === 'Tipo_Equipamento') && valor.trim() !== "") {
           linhaValida = true;
         }
       }

       // Adiciona o equipamento à lista apenas se a linha for considerada válida
       if(linhaValida) {
            // Garante que o status existe, mesmo que vazio na planilha
            if (!equip.hasOwnProperty('Status') || equip['Status'].trim() === '') {
                equip['Status'] = 'Disponível'; // Define 'Disponível' como padrão se status estiver vazio
            }
           equipamentos.push(equip);
       }
     }

     // Ordena por Placa (opcional)
     equipamentos.sort((a, b) => (a.Placa || '').localeCompare(b.Placa || ''));

     return { success: true, equipamentos: equipamentos };
   } catch (e) {
     Logger.log("Erro obterEquipamentos: " + e.message + "\nStack: " + e.stack);
     return { success: false, message: "Erro ao obter equipamentos: " + e.message };
   }
}

/** Salva ou atualiza um registro de manutenção. */
function salvarManutencao(dados) {
  // Usa lock para evitar condições de corrida ao salvar/atualizar
  var lock = LockService.getScriptLock();
  var lockAcquired = lock.tryLock(20000); // Tenta por 20s
   if (!lockAcquired) {
      Logger.log("salvarManutencao: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente salvar novamente." };
   }

  try {
    if (!dados || typeof dados !== 'object') {
      throw new Error("Dados inválidos ou ausentes para salvar a manutenção.");
    }

    var planilha = obterPlanilha();
    var abaManutencoes = planilha.getSheetByName(NOME_PLANILHA_MANUTENCOES);
    if (!abaManutencoes) {
      throw new Error(`Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.`);
    }

    var agora = new Date();
    var manutencaoId = dados.ID || dados.id || gerarId(); // Aceita ID ou id, gera novo se não existir
    var isUpdate = !!(dados.ID || dados.id); // Verifica se é uma atualização (tem ID)
    var responsavelAtual = dados.Responsavel || Session.getActiveUser()?.getEmail() || "Sistema";

    Logger.log(`Salvando manutenção ${manutencaoId}. É atualização? ${isUpdate}`);

    // --- Processamento de Imagens ---
    // Função auxiliar para processar e fazer upload de imagens base64
    const processarImagens = (imagensArray) => {
      if (!Array.isArray(imagensArray)) return []; // Retorna array vazio se não for array

      const imagensProcessadas = [];
      imagensArray.forEach(img => {
        if (img && img.isLocal === true && img.url && img.url.startsWith('data:image')) {
          // É uma imagem nova (local) para fazer upload
          try {
            // Logger.log(`Fazendo upload de nova imagem para ${manutencaoId}`); // Log muito verboso
            const uploadResult = uploadImagemBase64ParaDrive(manutencaoId, img.url);
            if (uploadResult.success) {
              imagensProcessadas.push({
                url: uploadResult.url,
                id: uploadResult.id,
                timestamp: img.timestamp || agora.toISOString() // Usa timestamp original ou atual
              });
              Logger.log(`Upload OK: ID ${uploadResult.id} para ${manutencaoId}`);
            } else {
              Logger.log(`Falha no upload da imagem local para ${manutencaoId}: ${uploadResult.message}`);
              // Decide se quer manter uma referência quebrada ou ignorar
              // imagensProcessadas.push({ url: 'falha_upload', id: null, timestamp: agora.toISOString() });
            }
          } catch (e) {
            Logger.log(`Erro durante upload da imagem local para ${manutencaoId}: ${e}`);
          }
        } else if (img && img.url && img.id) {
          // É uma imagem existente (já tem URL e ID do Drive), apenas mantém
          imagensProcessadas.push({
            url: img.url,
            id: img.id,
            timestamp: img.timestamp || 'N/A' // Mantém timestamp se existir
          });
        } else {
             Logger.log("Item inválido/incompleto no array de imagens: " + JSON.stringify(img));
        }
      });
      return imagensProcessadas;
    };

    var imagensPreProcessadas = processarImagens(dados.Imagens_Pre || dados.imagensPre); // Aceita ambos os nomes
    var imagensPosProcessadas = processarImagens(dados.Imagens_Pos || dados.imagensPos);

    // --- Preparação dos Dados para a Planilha ---
    var cabecalhos = abaManutencoes.getRange(1, 1, 1, abaManutencoes.getLastColumn()).getValues()[0].map(h => String(h).trim());
    var valoresParaSalvar = [];
    var dadosExistentes = null;
    var linhaExistente = -1;
    var statusAnterior = "";

    // Se for atualização, busca os dados existentes
    if (isUpdate) {
      var resultadoBusca = obterLinhaManutencaoPorId(abaManutencoes, cabecalhos, manutencaoId);
      if (resultadoBusca) {
        linhaExistente = resultadoBusca.linha;
        dadosExistentes = resultadoBusca.dadosLinha;
        statusAnterior = dadosExistentes['Status'] || ""; // Guarda o status antes da atualização
        Logger.log(`Manutenção ${manutencaoId} encontrada na linha ${linhaExistente}. Status anterior: ${statusAnterior}`);
      } else {
        // Se o ID foi fornecido mas não encontrado, tratar como erro ou criação?
        // Tratando como erro para evitar IDs órfãos. Se quiser criar, remova o throw.
        throw new Error(`Tentativa de atualizar manutenção com ID ${manutencaoId} não encontrada.`);
        // isUpdate = false; // Alternativa: Tratar como nova criação
        // manutencaoId = gerarId(); // Alternativa: Gerar novo ID
      }
    }

    // Monta o array de valores na ordem dos cabeçalhos
    for (var i = 0; i < cabecalhos.length; i++) {
      var nomeColuna = cabecalhos[i];
      var valor;

      switch (nomeColuna) {
        case 'ID':
          valor = manutencaoId;
          break;
        case 'Data_Criacao':
          // Mantém a data original na atualização, ou define agora se for novo
          valor = isUpdate && dadosExistentes && dadosExistentes['Data_Criacao'] ? dadosExistentes['Data_Criacao'] : agora;
          break;
        case 'Data_Atualizacao':
          valor = agora; // Sempre atualiza esta data
          break;
        case 'Status':
          // Usa o novo status, ou o anterior se não fornecido, ou o padrão se novo
          valor = dados.Status !== undefined ? dados.Status : (isUpdate && statusAnterior ? statusAnterior : STATUS_AGUARDANDO);
          break;
         case 'Responsavel':
             valor = responsavelAtual; // Usa o responsável dos dados ou usuário atual
             break;
        case 'Imagens_Pre':
          // Salva o array de objetos como string JSON
           try { valor = JSON.stringify(imagensPreProcessadas); } catch(e) { valor = "[]"; Logger.log("Erro stringify Imagens_Pre");}
          break;
        case 'Imagens_Pos':
          try { valor = JSON.stringify(imagensPosProcessadas); } catch(e) { valor = "[]"; Logger.log("Erro stringify Imagens_Pos");}
          break;
        case 'Checklist_Pre':
          // Garante que é um objeto, mesmo que vazio, e salva como JSON
           let checklistPre = dados.Checklist_Pre || dados.checklistPre || {};
           if(isUpdate && dadosExistentes && typeof dadosExistentes['Checklist_Pre'] === 'string' && !dados.Checklist_Pre && !dados.checklistPre) {
               try { checklistPre = JSON.parse(dadosExistentes['Checklist_Pre'] || '{}'); } catch(e){ checklistPre = {}; }
           }
           if (typeof checklistPre !== 'object' || checklistPre === null || Array.isArray(checklistPre)) checklistPre = {}; // Garante que é objeto
           try { valor = JSON.stringify(checklistPre); } catch(e) { valor = "{}"; Logger.log("Erro stringify Checklist_Pre");}
          break;
        case 'Checklist_Pos':
           let checklistPos = dados.Checklist_Pos || dados.checklistPos || {};
            if(isUpdate && dadosExistentes && typeof dadosExistentes['Checklist_Pos'] === 'string' && !dados.Checklist_Pos && !dados.checklistPos) {
               try { checklistPos = JSON.parse(dadosExistentes['Checklist_Pos'] || '{}'); } catch(e){ checklistPos = {}; }
           }
           if (typeof checklistPos !== 'object' || checklistPos === null || Array.isArray(checklistPos)) checklistPos = {};
           try { valor = JSON.stringify(checklistPos); } catch(e) { valor = "{}"; Logger.log("Erro stringify Checklist_Pos");}
          break;
        case 'Data_Manutencao':
           // Converte string de data recebida para objeto Date ou null
           let dataManutStr = dados.Data_Manutencao || dados.dataManutencao;
           if (dataManutStr) {
               try {
                   valor = new Date(dataManutStr);
                   if (isNaN(valor.getTime())) { // Verifica se a data é inválida
                       Logger.log("Data_Manutencao inválida recebida: " + dataManutStr);
                       valor = null;
                   }
               } catch (dateErr) {
                    Logger.log("Erro ao converter Data_Manutencao: " + dataManutStr + " - " + dateErr);
                   valor = null;
               }
           } else {
               // Se for atualização e já existia uma data, mantém? Ou permite limpar?
               // Decisão: Permite limpar se não vier nada.
               valor = isUpdate && dadosExistentes ? dadosExistentes['Data_Manutencao'] : null; // Mantem se ja existia
               if(valor === "" || (valor instanceof Date && isNaN(valor.getTime()))) valor = null; // Considera "" como null
           }
           // Se status for Concluído/Disponível e não houver data, preenche com agora
           let statusAtualTemp = dados.Status || (isUpdate ? statusAnterior : STATUS_AGUARDANDO);
           if (!valor && (statusAtualTemp === STATUS_CONCLUIDO || statusAtualTemp === STATUS_DISPONIVEL)) {
               valor = agora;
           }
          break;
        default:
          // Para outras colunas, usa o valor dos dados recebidos,
          // ou o valor existente se for atualização e não foi fornecido novo valor,
          // ou string vazia como padrão.
          valor = dados[nomeColuna] !== undefined ? dados[nomeColuna] : (isUpdate && dadosExistentes && dadosExistentes[nomeColuna] !== undefined ? dadosExistentes[nomeColuna] : '');
      }

      // Tratamento final para garantir que o valor é adequado para a planilha
      if (typeof valor === 'object' && valor !== null && !(valor instanceof Date)) {
        // Se for objeto (não Date), tenta converter para JSON. Evita erro [object Object]
        try { valor = JSON.stringify(valor); }
        catch (e) { valor = "[Erro ao serializar objeto]"; Logger.log(`Erro ao serializar ${nomeColuna}: ${e}`);}
      }
      // Garante que não seja null ou undefined, substituindo por string vazia
      valoresParaSalvar.push(valor !== null && valor !== undefined ? valor : '');
    }

    // --- Escrita na Planilha ---
    if (linhaExistente > 0) {
      // Atualiza a linha existente
      abaManutencoes.getRange(linhaExistente, 1, 1, valoresParaSalvar.length).setValues([valoresParaSalvar]);
      Logger.log(`Linha ${linhaExistente} atualizada para ID ${manutencaoId}.`);
    } else {
      // Adiciona nova linha
      abaManutencoes.appendRow(valoresParaSalvar);
      linhaExistente = abaManutencoes.getLastRow(); // Pega a linha da nova inserção
      Logger.log(`Nova linha ${linhaExistente} adicionada para ID ${manutencaoId}.`);
    }

    // --- Ações Pós-Salvamento ---
    var statusAtual = valoresParaSalvar[cabecalhos.indexOf('Status')];
    var placaAtual = valoresParaSalvar[cabecalhos.indexOf('Placa')];
    var responsavelFinal = valoresParaSalvar[cabecalhos.indexOf('Responsavel')];

    // Atualiza o status do equipamento correspondente
    if (placaAtual) {
      atualizarStatusEquipamento(placaAtual, statusAtual);
    }

    // Registra no histórico se for criação ou se o status mudou
    if (!isUpdate || (statusAtual !== statusAnterior)) {
      registrarHistorico(
        manutencaoId,
        placaAtual,
        isUpdate ? statusAnterior : "-", // Status anterior ou "-" para criação
        statusAtual,
        responsavelFinal,
        isUpdate ? `Atualização de Status (${statusAnterior} -> ${statusAtual})` : "Criação de Registro"
      );
    } else if (isUpdate) {
         // Mesmo sem mudança de status, registrar a edição (se desejado)
         // registrarHistorico(manutencaoId, placaAtual, statusAtual, statusAtual, responsavelFinal, "Edição de dados");
         // Decisão atual: Registrar apenas mudança de status ou criação
    }


    // Envia e-mail de notificação apropriado
    if (!isUpdate) {
       enviarEmailNotificacao(manutencaoId, [], 'nova'); // Notifica nova solicitação
       if (dados.Urgencia === 'Alta') { // Se for urgente, manda alerta adicional
           enviarEmailNotificacao(manutencaoId, [], 'alerta');
       }
    } else if (statusAtual !== statusAnterior) {
       let tipoEmail = (statusAtual === STATUS_CONCLUIDO || statusAtual === STATUS_DISPONIVEL) ? 'conclusao' : 'atualizacao';
       enviarEmailNotificacao(manutencaoId, [], tipoEmail); // Notifica mudança de status
    }


    // Busca os dados salvos para retornar ao frontend
    const manutencaoSalva = obterManutencao(manutencaoId);

    return {
      success: true,
      message: isUpdate ? "Manutenção atualizada com sucesso!" : "Manutenção registrada com sucesso!",
      id: manutencaoId,
      manutencao: manutencaoSalva.success ? manutencaoSalva.manutencao : null // Retorna o objeto completo
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO em salvarManutencao: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao salvar manutenção: " + e.message };
  } finally {
    if (lockAcquired) {
        lock.releaseLock(); // Libera o lock SEMPRE que for adquirido
    }
  }
}


/** Exclui um registro de manutenção. */
function excluirManutencao(id) {
  var lock = LockService.getScriptLock();
  var lockAcquired = lock.tryLock(15000); // Tenta por 15s
  if (!lockAcquired) {
      Logger.log("excluirManutencao: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente excluir novamente." };
   }

  try {
    if (!id) throw new Error("ID não fornecido para exclusão.");
    Logger.log(`Tentando excluir manutenção ID: ${id}`);

    var planilha = obterPlanilha();
    var abaManutencoes = planilha.getSheetByName(NOME_PLANILHA_MANUTENCOES);

    if (!abaManutencoes) {
      throw new Error(`Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.`);
    }

    var cabecalhos = abaManutencoes.getRange(1, 1, 1, abaManutencoes.getLastColumn()).getValues()[0].map(h => String(h).trim());
    var resLinha = obterLinhaManutencaoPorId(abaManutencoes, cabecalhos, id);

    if (!resLinha) {
      // Se não encontrou a linha, talvez já tenha sido excluída. Retorna sucesso mas avisa.
      Logger.log(`Manutenção ID ${id} não encontrada para exclusão (pode já ter sido excluída).`);
      return { success: true, message: `Manutenção ID ${id} não encontrada.` };
      // Ou lançar erro: throw new Error(`Manutenção ID ${id} não encontrada para exclusão.`);
    }

    Logger.log(`Manutenção ${id} encontrada na linha ${resLinha.linha}. Procedendo com exclusão.`);

    // Obter informações ANTES de excluir a linha (placa, imagens)
    var dadosManut = resLinha.dadosLinha;
    var placa = dadosManut['Placa'] || "";
    var imagensPreStr = dadosManut['Imagens_Pre'] || '[]';
    var imagensPosStr = dadosManut['Imagens_Pos'] || '[]';

    // Excluir todas as imagens associadas no Drive
     if (PASTA_IMAGENS_ID) { // Só tenta excluir se a pasta raiz estiver configurada
        try {
            const excluirArquivosImagem = (jsonStringImagens) => {
                let imagens = [];
                try { imagens = JSON.parse(jsonStringImagens); } catch(e) { Logger.log(`Erro ao parsear JSON de imagens para exclusão: ${jsonStringImagens} - ${e}`); return; }

                if (Array.isArray(imagens)) {
                    imagens.forEach(img => {
                        if (img && img.id) {
                            try {
                                const file = DriveApp.getFileById(img.id);
                                file.setTrashed(true); // Move para a lixeira
                                Logger.log(`Imagem ${img.id} (ref ${id}) movida para a lixeira.`);
                            } catch (e) {
                                // Pode falhar se o arquivo já foi excluído ou permissão mudou
                                Logger.log(`AVISO: Falha ao mover imagem ${img.id} (ref ${id}) para a lixeira: ${e.message}`);
                            }
                        }
                    });
                }
            };

            Logger.log(`Excluindo imagens pré para ${id}`);
            excluirArquivosImagem(imagensPreStr);
            Logger.log(`Excluindo imagens pós para ${id}`);
            excluirArquivosImagem(imagensPosStr);

            // Tenta excluir a pasta específica da manutenção (se existir)
            try {
                const pastaRoot = DriveApp.getFolderById(PASTA_IMAGENS_ID);
                const pastasManut = pastaRoot.getFoldersByName(id); // Busca a pasta pelo ID da manutenção
                if (pastasManut.hasNext()) {
                    const pastaParaExcluir = pastasManut.next();
                    pastaParaExcluir.setTrashed(true);
                    Logger.log(`Pasta de imagens ${id} (${pastaParaExcluir.getId()}) movida para a lixeira.`);
                     // Verificar se há mais pastas com mesmo nome (improvável, mas possível)
                    if (pastasManut.hasNext()) {
                        Logger.log(`AVISO: Múltiplas pastas encontradas para a manutenção ${id}. Apenas a primeira foi movida para lixeira.`);
                    }
                } else {
                    // Logger.log(`Pasta de imagens específica para ${id} não encontrada.`); // Log menos verboso
                }
            } catch (e) {
                Logger.log(`Erro ao tentar excluir pasta de imagens ${id}: ${e.message}`);
            }
        } catch (e) {
            Logger.log(`Erro geral ao processar exclusão de imagens/pasta para ${id}: ${e.message}`);
        }
    } else {
         Logger.log("AVISO: PASTA_IMAGENS_ID não configurada. Pulando exclusão de arquivos no Drive.");
    }


    // Excluir a linha da manutenção na planilha
    abaManutencoes.deleteRow(resLinha.linha);
    Logger.log(`Linha ${resLinha.linha} (ID ${id}) excluída da aba ${NOME_PLANILHA_MANUTENCOES}.`);

    // Atualizar status do equipamento se necessário
    if (placa) {
      // Verifica se AINDA existem OUTRAS manutenções abertas para este equipamento
      const resOutrasManut = listarManutencoes(null, placa, 10); // Lista algumas (status null = todas)
      let temOutraManutencaoAberta = false;
      if (resOutrasManut.success && Array.isArray(resOutrasManut.manutencoes)) {
        temOutraManutencaoAberta = resOutrasManut.manutencoes.some(m =>
             m.ID !== id && // Garante que não é a manutenção que acabamos de excluir
            (m.Status === STATUS_AGUARDANDO || m.Status === STATUS_EM_MANUTENCAO)
        );
      }

      if (!temOutraManutencaoAberta) {
        // Se não há mais manutenções abertas, marca o equipamento como Disponível
        Logger.log(`Nenhuma outra manutenção aberta encontrada para ${placa}. Atualizando status para Disponível.`);
        atualizarStatusEquipamento(placa, STATUS_DISPONIVEL);
      } else {
          Logger.log(`Ainda existem outras manutenções abertas para ${placa}. Status do equipamento não alterado.`);
          // Opcional: Poderia atualizar para o status da manutenção mais recente, se desejado.
      }
    }

    // Registra a exclusão no histórico
    registrarHistorico(id, placa, dadosManut['Status'] || "N/A", "Excluído", Session.getActiveUser()?.getEmail() || "Sistema", "Registro de manutenção excluído");

    return {
      success: true,
      message: "Manutenção excluída com sucesso."
    };
  } catch (e) {
    Logger.log(`Erro CRÍTICO em excluirManutencao ${id}: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao excluir manutenção: " + e.message };
  } finally {
     if (lockAcquired) {
        lock.releaseLock();
     }
  }
}


/** Atualiza o status de um equipamento na aba 'Equipamentos'. */
function atualizarStatusEquipamento(placa, statusManutencao) {
   try {
     if (!placa || !statusManutencao) {
         // Logger.log(`atualizarStatusEquipamento: Placa (${placa}) ou Status (${statusManutencao}) inválido.`);
         return; // Não faz nada se não tiver placa ou status
     }

     var plan = obterPlanilha();
     var abaEq = plan.getSheetByName(NOME_PLANILHA_EQUIPAMENTOS);
     if (!abaEq) {
          Logger.log(`atualizarStatusEquipamento: Aba '${NOME_PLANILHA_EQUIPAMENTOS}' não encontrada.`);
          return;
     }

     var dados = abaEq.getDataRange().getValues();
     if (dados.length <= 1) {
         // Logger.log(`atualizarStatusEquipamento: Aba '${NOME_PLANILHA_EQUIPAMENTOS}' está vazia (sem dados).`);
         return;
     }

     var cabecalhos = dados[0].map(h => String(h).trim());
     var placaColIdx = cabecalhos.indexOf('Placa');
     var statusColIdx = cabecalhos.indexOf('Status');
     var ultManutColIdx = cabecalhos.indexOf('Ultima_Manutencao');

     if (placaColIdx === -1 || statusColIdx === -1) {
       Logger.log(`atualizarStatusEquipamento: Colunas 'Placa' ou 'Status' não encontradas na aba '${NOME_PLANILHA_EQUIPAMENTOS}'.`);
       return;
     }
      if (ultManutColIdx === -1) {
         // Logger.log(`AVISO: Coluna 'Ultima_Manutencao' não encontrada em '${NOME_PLANILHA_EQUIPAMENTOS}'. A data não será atualizada.`);
     }

     // Mapeia o status da MANUTENÇÃO para o status do EQUIPAMENTO
     var statusEquipamento;
     switch (statusManutencao) {
       case STATUS_AGUARDANDO:
           statusEquipamento = "Aguardando Manutenção";
           break;
       case STATUS_EM_MANUTENCAO:
           statusEquipamento = "Em Manutenção";
           break;
       case STATUS_CONCLUIDO: // Manutenção concluída significa que equipamento está disponível
       case STATUS_DISPONIVEL: // Status já indica disponível
           statusEquipamento = "Disponível";
           break;
       default:
         // Se o status da manutenção for desconhecido, não altera o status do equipamento
         Logger.log(`atualizarStatusEquipamento: Status de manutenção '${statusManutencao}' não mapeado para status de equipamento.`);
         return;
     }

     let encontrado = false;
     // Procura pela placa na coluna correspondente
     for (var i = 1; i < dados.length; i++) {
       if (String(dados[i][placaColIdx]).trim().toUpperCase() === String(placa).trim().toUpperCase()) { // Comparação case-insensitive
         // Logger.log(`Equipamento ${placa} encontrado na linha ${i+1}. Atualizando status para '${statusEquipamento}'.`);
         // Atualiza o status na célula correta
         const statusCell = abaEq.getRange(i + 1, statusColIdx + 1);
         // Só atualiza se o status for diferente para evitar escritas desnecessárias
         if(statusCell.getValue() !== statusEquipamento) {
            statusCell.setValue(statusEquipamento);
             Logger.log(`Status do equipamento ${placa} atualizado para '${statusEquipamento}' na linha ${i+1}.`);
         }

         encontrado = true;

         // Se o status for Disponível (vindo de Concluído ou Disponível) E a coluna existe, atualiza a data da última manutenção
         if (statusEquipamento === "Disponível" && ultManutColIdx !== -1) {
           const ultManutCell = abaEq.getRange(i + 1, ultManutColIdx + 1);
           // Atualiza a data apenas se a data atual for diferente (ou vazia)
           const dataAtual = new Date();
           const dataExistente = ultManutCell.getValue();
           let precisaAtualizarData = true;
           if(dataExistente instanceof Date && !isNaN(dataExistente.getTime())) {
               // Compara apenas dia/mês/ano para não atualizar múltiplas vezes no mesmo dia
                if(Utilities.formatDate(dataExistente, Session.getScriptTimeZone(), "yyyy-MM-dd") === Utilities.formatDate(dataAtual, Session.getScriptTimeZone(), "yyyy-MM-dd")) {
                   precisaAtualizarData = false;
                }
           }
           if(precisaAtualizarData) {
                ultManutCell.setValue(dataAtual).setNumberFormat('dd/mm/yyyy');
                Logger.log(`Data da Última Manutenção atualizada para ${placa}.`);
           }
         }
         break; // Para o loop assim que encontrar a placa
       }
     }

     if (!encontrado) {
       Logger.log(`AVISO: Equipamento com placa '${placa}' não encontrado na aba '${NOME_PLANILHA_EQUIPAMENTOS}'. Status não atualizado.`);
     }
   } catch (e) {
     // Loga o erro mas não impede a execução de outras partes do script
     Logger.log(`Erro em atualizarStatusEquipamento para placa ${placa}: ${e.message}\n${e.stack}`);
   }
}


/** Registra uma entrada na aba 'Histórico'. */
function registrarHistorico(manutencaoId, placa, statusAnterior, statusNovo, responsavel, observacao) {
   try {
     // Validação básica dos dados essenciais
     if (!manutencaoId || !statusNovo) {
        // Logger.log(`registrarHistorico: ID da Manutenção (${manutencaoId}) ou Status Novo (${statusNovo}) ausente. Registro não criado.`);
        return;
     }

     var plan = obterPlanilha();
     var abaHist = plan.getSheetByName(NOME_PLANILHA_HISTORICO);
     if (!abaHist) {
         Logger.log(`registrarHistorico: Aba '${NOME_PLANILHA_HISTORICO}' não encontrada.`);
         return; // Não pode registrar sem a aba
     }

     // Define o responsável (usuário atual ou 'Sistema')
     var resp = responsavel || Session.getActiveUser()?.getEmail() || "Sistema";
     var dataAtual = new Date();

      // Prepara a linha de dados para o histórico
      var dadosLinha = [
         manutencaoId,
         dataAtual,
         placa || 'N/A', // Garante que a placa não seja nula
         statusAnterior || '-', // Usa '-' se o status anterior for nulo/vazio
         statusNovo,
         resp,
         observacao || '' // Usa string vazia se a observação for nula/vazia
      ];

     // Adiciona a linha ao final da aba Histórico
     abaHist.appendRow(dadosLinha);
     // Logger.log(`Registro adicionado ao histórico para ID ${manutencaoId}: ${statusAnterior} -> ${statusNovo} por ${resp}`);

   } catch (e) {
     // Loga o erro mas não impede a execução de outras partes
     Logger.log(`Erro em registrarHistorico para ID ${manutencaoId}: ${e.message}\n${e.stack}`);
   }
}


/** Atualiza o status de uma manutenção específica. */
function atualizarStatusManutencao(id, status) {
   var lock = LockService.getScriptLock();
   var lockAcquired = lock.tryLock(15000);
    if (!lockAcquired) {
      Logger.log("atualizarStatusManutencao: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente atualizar novamente." };
    }

   try {
     if (!id || !status) throw new Error("ID da manutenção ou novo Status inválido/ausente.");

     // Valida se o status fornecido é um dos status válidos
     const statusValidos = [STATUS_AGUARDANDO, STATUS_EM_MANUTENCAO, STATUS_CONCLUIDO, STATUS_DISPONIVEL];
     if (!statusValidos.includes(status)) {
         throw new Error(`Status '${status}' não é um valor válido.`);
     }

     // 1. Obtém os dados atuais da manutenção para pegar o status anterior e placa
     var resManut = obterManutencao(id);
     if (!resManut.success || !resManut.manutencao) {
       throw new Error(resManut.message || `Manutenção com ID ${id} não encontrada.`);
     }

     var manutAtual = resManut.manutencao;
     var statusAnterior = manutAtual.Status;
     var placa = manutAtual.Placa;

     // 2. Verifica se o status já é o desejado
     if (statusAnterior === status) {
       Logger.log(`Status da manutenção ${id} já é '${status}'. Nenhuma alteração necessária.`);
       return { success: true, message: "O status já está atualizado." };
     }

     // 3. Acessa a aba de Manutenções
     var plan = obterPlanilha();
     var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
     if (!abaM) {
       throw new Error(`Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.`);
     }

     // 4. Encontra a linha da manutenção
     var cabecalhos = abaM.getRange(1, 1, 1, abaM.getLastColumn()).getValues()[0].map(h=>h.trim());
     var resLinha = obterLinhaManutencaoPorId(abaM, cabecalhos, id);

     if (!resLinha) {
       // Deveria ter sido encontrado por obterManutencao, mas checa novamente por segurança
       throw new Error(`Manutenção ID ${id} não encontrada na planilha (inconsistência?).`);
     }

     var linha = resLinha.linha;
     var statusColIdx = cabecalhos.indexOf('Status');
     var dtAtualizacaoColIdx = cabecalhos.indexOf('Data_Atualizacao');
     var dtManutencaoColIdx = cabecalhos.indexOf('Data_Manutencao');
     var responsavelColIdx = cabecalhos.indexOf('Responsavel'); // Coluna do responsável

     if (statusColIdx === -1 || dtAtualizacaoColIdx === -1) {
       throw new Error("Colunas essenciais ('Status', 'Data_Atualizacao') não encontradas na aba Manutenções.");
     }
      if (dtManutencaoColIdx === -1) {
         Logger.log("AVISO: Coluna 'Data_Manutencao' não encontrada. Não será preenchida automaticamente.");
     }
      if (responsavelColIdx === -1) {
         Logger.log("AVISO: Coluna 'Responsavel' não encontrada. Não será atualizada.");
     }


     // 5. Atualiza os valores na planilha
     var agora = new Date();
     var responsavel = Session.getActiveUser()?.getEmail() || "Sistema";

     abaM.getRange(linha, statusColIdx + 1).setValue(status); // Atualiza Status
     abaM.getRange(linha, dtAtualizacaoColIdx + 1).setValue(agora); // Atualiza Data_Atualizacao

     // Atualiza Responsável se a coluna existir
     if (responsavelColIdx !== -1) {
         abaM.getRange(linha, responsavelColIdx + 1).setValue(responsavel);
     }


     // Se o novo status for Concluído ou Disponível E a Data_Manutencao estiver vazia E a coluna existe, preenche com agora
     if ((status === STATUS_CONCLUIDO || status === STATUS_DISPONIVEL) && dtManutencaoColIdx !== -1) {
         const dataManutCell = abaM.getRange(linha, dtManutencaoColIdx + 1);
         const dataManutAtual = dataManutCell.getValue();
         if (!dataManutAtual || (dataManutAtual instanceof Date && isNaN(dataManutAtual.getTime()))) { // Só preenche se estiver vazia ou inválida
             dataManutCell.setValue(agora).setNumberFormat('dd/mm/yyyy hh:mm:ss');
             Logger.log(`Data_Manutencao preenchida automaticamente para ${id} na linha ${linha}.`);
         }
     }

     Logger.log(`Status da manutenção ${id} atualizado para '${status}' na linha ${linha}.`);

     // 6. Atualiza o status do equipamento correspondente
     if (placa) {
       atualizarStatusEquipamento(placa, status);
     }

     // 7. Registra a alteração no histórico
     registrarHistorico(id, placa, statusAnterior, status, responsavel, `Status alterado via ${Session.getActiveUser() ? 'interface/usuário' : 'sistema'}`);

     // 8. Envia notificação por e-mail sobre a atualização/conclusão
     let tipoEmail = (status === STATUS_CONCLUIDO || status === STATUS_DISPONIVEL) ? 'conclusao' : 'atualizacao';
     enviarEmailNotificacao(id, [], tipoEmail);

     // 9. Retorna o objeto de manutenção atualizado
     const manutAtualizada = obterManutencao(id);

     return {
         success: true,
         message: "Status da manutenção atualizado com sucesso.",
         manutencao: manutAtualizada.success ? manutAtualizada.manutencao : null // Inclui o objeto atualizado
     };

   } catch (e) {
     Logger.log(`Erro em atualizarStatusManutencao para ID ${id}: ${e.message}\n${e.stack}`);
     return { success: false, message: "Erro ao atualizar status: " + e.message };
   } finally {
     if (lockAcquired) {
        lock.releaseLock();
     }
   }
}


/** Obtém os dados de uma manutenção específica pelo ID. */
function obterManutencao(id) {
    try {
      if (!id) return { success: false, message: "ID da manutenção não fornecido." };

      var plan = obterPlanilha();
      var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
      if (!abaM) return { success: false, message: `Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.` };

      var dados = abaM.getDataRange().getValues();
      if (dados.length <= 1) return { success: false, manutencao: null, message: `Nenhuma manutenção encontrada na aba.` };

      var cabecalhos = dados[0].map(h => String(h).trim());
      var idColIdx = cabecalhos.indexOf('ID');

      if (idColIdx === -1) return { success: false, message: "Coluna 'ID' não encontrada na aba Manutenções." };

      // Procura pela linha com o ID correspondente
      for (var i = 1; i < dados.length; i++) {
        if (String(dados[i][idColIdx]).trim() === String(id).trim()) {
          var manutencao = {};

          // Monta o objeto de manutenção com base nos cabeçalhos
          for (var j = 0; j < cabecalhos.length; j++) {
            var header = cabecalhos[j];
            if (!header) continue; // Ignora colunas sem cabeçalho

            var valor = dados[i][j];

            // Tratamento especial para colunas que armazenam JSON (Checklist, Imagens)
            if (header.startsWith('Checklist_') || header.startsWith('Imagens_')) {
              let parsedValue;
              const isImagem = header.startsWith('Imagens_');
              const defaultValue = isImagem ? [] : {}; // Default é array para imagens, objeto para checklist

              if (typeof valor === 'string' && valor.trim()) {
                try {
                  parsedValue = JSON.parse(valor);
                  // Validação adicional do tipo após o parse
                  if (isImagem && !Array.isArray(parsedValue)) {
                      // Logger.log(`AVISO [obterManutencao ${id}]: Valor em ${header} não é um array após parse: ${valor}. Usando default.`);
                      parsedValue = defaultValue;
                  } else if (!isImagem && (typeof parsedValue !== 'object' || parsedValue === null || Array.isArray(parsedValue))) {
                      // Logger.log(`AVISO [obterManutencao ${id}]: Valor em ${header} não é um objeto após parse: ${valor}. Usando default.`);
                      parsedValue = defaultValue;
                  }
                } catch (e) {
                  // Logger.log(`Erro ao parsear JSON em ${header} para ID ${id}: ${valor} - ${e.message}. Usando default.`);
                  parsedValue = defaultValue;
                }
              } else if (isImagem && Array.isArray(valor)) {
                  // Se já for um array (caso raro, mas possível se a célula foi manipulada), usa direto
                  parsedValue = valor;
              } else if (!isImagem && typeof valor === 'object' && valor !== null && !Array.isArray(valor)){
                  // Se já for um objeto (caso raro), usa direto
                  parsedValue = valor;
              } else {
                 // Se não for string ou estiver vazio, ou tipo inesperado, usa o default
                 parsedValue = defaultValue;
              }
              valor = parsedValue;
            }
            // Tratamento especial para colunas de Data
            else if ((header === 'Data_Criacao' || header === 'Data_Manutencao' || header === 'Data_Atualizacao') &&
                      valor instanceof Date && !isNaN(valor.getTime())) {
              // Formata como ISO string para consistência
              valor = valor.toISOString();
            }
             // Tratamento para garantir que outros valores sejam strings
            else {
               valor = valor !== undefined && valor !== null ? String(valor) : "";
            }

            manutencao[header] = valor;
          }

          // Adiciona o número da linha para referência, se útil
          // manutencao['_linha'] = i + 1;

          return { success: true, manutencao: manutencao };
        }
      }

      // Se o loop terminou sem encontrar o ID
      return { success: false, manutencao: null, message: `Manutenção com ID ${id} não encontrada.` };

    } catch (e) {
      Logger.log(`Erro CRÍTICO em obterManutencao para ID ${id}: ${e.message}\n${e.stack}`);
      return { success: false, message: "Erro interno ao obter dados da manutenção: " + e.message };
    }
}


/** Lista manutenções, com filtros opcionais. */
function listarManutencoes(status, placa, limite) {
    try {
      var plan = obterPlanilha();
      var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
      if (!abaM) return { success: false, message: `Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.` };

      var dados = abaM.getDataRange().getValues();
      if (dados.length <= 1) return { success: true, manutencoes: [] }; // Nenhuma manutenção

      var cabecalhos = dados[0].map(h => String(h).trim());
      var statusColIdx = cabecalhos.indexOf('Status');
      var placaColIdx = cabecalhos.indexOf('Placa');
      var dtCriacaoColIdx = cabecalhos.indexOf('Data_Criacao'); // Para ordenação

      // Verifica se colunas essenciais para filtro/ordenação existem
      if (statusColIdx === -1 && status)
        return { success: false, message: "Coluna 'Status' não encontrada para filtrar." };
      if (placaColIdx === -1 && placa)
        return { success: false, message: "Coluna 'Placa' não encontrada para filtrar." };
      if (dtCriacaoColIdx === -1)
          Logger.log("AVISO: Coluna 'Data_Criacao' não encontrada. A ordenação pode não ser por data de criação.");


      var limiteNum = limite ? parseInt(limite) : 0; // Converte limite para número, 0 = sem limite
      if (isNaN(limiteNum) || limiteNum < 0) limiteNum = 0;

       // Filtra e mapeia os dados
      var manutencoesFiltradas = [];
      // Itera de baixo para cima se a ordenação padrão for por data decrescente e não houver limite
      // Ou de cima para baixo e ordena depois
      for (var i = 1; i < dados.length; i++) {
          const linha = dados[i];
          let match = true;

          // Aplica filtro de Status (se fornecido)
          if (status && statusColIdx !== -1 && String(linha[statusColIdx]).trim() !== status) {
              match = false;
          }

          // Aplica filtro de Placa (se fornecido, busca parcial case-insensitive)
          if (match && placa && placaColIdx !== -1) {
              if (!String(linha[placaColIdx]).trim().toLowerCase().includes(placa.toLowerCase())) {
                  match = false;
              }
          }

          if (match) {
              // Mapeia a linha para um objeto de manutenção (similar a obterManutencao)
               var manut = {};
               for (var j = 0; j < cabecalhos.length; j++) {
                   var h = cabecalhos[j];
                   if (!h) continue;

                   var v = linha[j];
                   // Reutiliza a lógica de parse/formatação de obterManutencao
                    if (h.startsWith('Checklist_') || h.startsWith('Imagens_')) {
                       let parsedValue;
                       const isImagem = h.startsWith('Imagens_');
                       const defaultValue = isImagem ? [] : {};
                       if (typeof v === 'string' && v.trim()) {
                           try {
                               parsedValue = JSON.parse(v);
                               if (isImagem && !Array.isArray(parsedValue)) parsedValue = defaultValue;
                               else if (!isImagem && (typeof parsedValue !== 'object' || parsedValue === null || Array.isArray(parsedValue))) parsedValue = defaultValue;
                           } catch (e) { parsedValue = defaultValue; }
                       } else if (isImagem && Array.isArray(v)) {
                            parsedValue = v;
                       } else if (!isImagem && typeof v === 'object' && v !== null && !Array.isArray(v)){
                           parsedValue = v;
                       } else {
                            parsedValue = defaultValue;
                       }
                       v = parsedValue;
                   } else if ((h === 'Data_Criacao' || h === 'Data_Manutencao' || h === 'Data_Atualizacao') && v instanceof Date && !isNaN(v.getTime())) {
                       v = v.toISOString();
                   } else {
                       v = v !== undefined && v !== null ? String(v) : "";
                   }
                   manut[h] = v;
               }
               manutencoesFiltradas.push(manut);
          }
      }

      // Ordena por Data de Criação (mais recentes primeiro) se a coluna existe
      if (dtCriacaoColIdx !== -1) {
          manutencoesFiltradas.sort((a, b) => {
              // Tenta converter as datas ISO string de volta para comparar
              let dateA = 0; try { dateA = new Date(a.Data_Criacao).getTime(); if(isNaN(dateA)) dateA=0; } catch(e){}
              let dateB = 0; try { dateB = new Date(b.Data_Criacao).getTime(); if(isNaN(dateB)) dateB=0; } catch(e){}
              return dateB - dateA; // Decrescente
          });
      } else {
          // Se não tem data de criação, a ordem será a da planilha (ou a ordem de inserção no array)
      }


      // Aplica o limite, se houver
      if (limiteNum > 0) {
        manutencoesFiltradas = manutencoesFiltradas.slice(0, limiteNum);
      }

      return { success: true, manutencoes: manutencoesFiltradas };
    } catch (e) {
      Logger.log(`Erro em listarManutencoes: ${e.message}\n${e.stack}`);
      return { success: false, message: "Erro ao listar manutenções: " + e.message };
    }
}


/** Obtém dados agregados para o Dashboard. */
function obterDadosDashboard() {
    try {
      var plan = obterPlanilha();
      var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
      var abaE = plan.getSheetByName(NOME_PLANILHA_EQUIPAMENTOS);
      var abaH = plan.getSheetByName(NOME_PLANILHA_HISTORICO);

      if (!abaM || !abaE || !abaH) {
          let msg = "Abas não encontradas para o Dashboard: ";
          if (!abaM) msg += `'${NOME_PLANILHA_MANUTENCOES}' `;
          if (!abaE) msg += `'${NOME_PLANILHA_EQUIPAMENTOS}' `;
          if (!abaH) msg += `'${NOME_PLANILHA_HISTORICO}' `;
          return { success: false, message: msg.trim() };
      }

      // --- Leitura dos Dados ---
      var dadosManutencoes = abaM.getDataRange().getValues();
      var dadosEquipamentos = abaE.getDataRange().getValues();
      var dadosHistorico = abaH.getDataRange().getValues();

      // --- Inicialização dos Contadores e Estruturas ---
      var contadoresStatusManut = {
        [STATUS_AGUARDANDO]: 0,
        [STATUS_EM_MANUTENCAO]: 0,
        [STATUS_CONCLUIDO]: 0,
        [STATUS_DISPONIVEL]: 0, // Inclui Disponível explicitamente
        'Outros': 0 // Para status não mapeados
      };
      var contadoresCategoriaProblema = {};
      var contadoresTipoEquipManut = {}; // Tipos de equipamento *em manutenções*
      var tempoMedioResolucaoPorTipo = {}; // { tipo: { totalHoras: 0, contagem: 0 } }
      var manutencoesRecentes = []; // Array de objetos {id, placa, tipoEquipamento, dataCriacao, status}
      var atividadeRecenteHistorico = []; // Array de objetos {data, placa, statusAnterior, statusNovo}
      var statusEquipamentosGeral = { total: 0, disponivel: 0, em_manutencao: 0, aguardando: 0, desativado: 0, outros: 0 };

      // --- Processamento Aba Manutenções ---
      if (dadosManutencoes.length > 1) {
        var cabecalhosM = dadosManutencoes[0].map(h=>String(h).trim());
        var idxStatusM = cabecalhosM.indexOf('Status');
        var idxCategoriaM = cabecalhosM.indexOf('Categoria_Problema');
        var idxTipoEquipM = cabecalhosM.indexOf('Tipo_Equipamento');
        var idxDataCriacaoM = cabecalhosM.indexOf('Data_Criacao');
        var idxDataManutencaoM = cabecalhosM.indexOf('Data_Manutencao');
        var idxIdM = cabecalhosM.indexOf('ID');
        var idxPlacaM = cabecalhosM.indexOf('Placa');

        // Itera pelas manutenções (pulando cabeçalho)
        // Processar em ordem decrescente de linha para pegar as mais recentes primeiro
        for (var i = dadosManutencoes.length - 1; i > 0; i--) {
          var linhaM = dadosManutencoes[i];

          // Contagem por Status
          var status = idxStatusM !== -1 ? String(linhaM[idxStatusM]).trim() : null;
          if (status && contadoresStatusManut.hasOwnProperty(status)) {
              contadoresStatusManut[status]++;
          } else if (status) {
              contadoresStatusManut['Outros']++; // Conta status inesperados
          }

          // Contagem por Categoria de Problema
          var categoria = idxCategoriaM !== -1 ? String(linhaM[idxCategoriaM]).trim() : null;
          if (categoria) {
              contadoresCategoriaProblema[categoria] = (contadoresCategoriaProblema[categoria] || 0) + 1;
          }

           // Contagem por Tipo de Equipamento (na manutenção)
          var tipoEquip = idxTipoEquipM !== -1 ? String(linhaM[idxTipoEquipM]).trim() : null;
          if (tipoEquip) {
              contadoresTipoEquipManut[tipoEquip] = (contadoresTipoEquipManut[tipoEquip] || 0) + 1;
          }

          // Cálculo Tempo Médio de Resolução
          var dataCriacao = idxDataCriacaoM !== -1 && linhaM[idxDataCriacaoM] instanceof Date ? linhaM[idxDataCriacaoM] : null;
          var dataManutencao = idxDataManutencaoM !== -1 && linhaM[idxDataManutencaoM] instanceof Date ? linhaM[idxDataManutencaoM] : null;

          if (tipoEquip && dataCriacao && dataManutencao && dataManutencao >= dataCriacao && (status === STATUS_CONCLUIDO || status === STATUS_DISPONIVEL)) {
             var diffHoras = (dataManutencao.getTime() - dataCriacao.getTime()) / (1000 * 60 * 60); // Diferença em horas
             if (!tempoMedioResolucaoPorTipo[tipoEquip]) {
                 tempoMedioResolucaoPorTipo[tipoEquip] = { totalHoras: 0, contagem: 0 };
             }
             tempoMedioResolucaoPorTipo[tipoEquip].totalHoras += diffHoras;
             tempoMedioResolucaoPorTipo[tipoEquip].contagem++;
          }

          // Manutenções Recentes (pega as últimas 5)
          if (manutencoesRecentes.length < 5 && idxIdM !== -1 && idxPlacaM !== -1 && dataCriacao) {
             manutencoesRecentes.push({
                 id: String(linhaM[idxIdM]).trim(),
                 placa: String(linhaM[idxPlacaM]).trim() || 'N/A',
                 tipoEquipamento: tipoEquip || 'N/A',
                 dataCriacao: dataCriacao.toISOString(),
                 status: status || 'N/A'
             });
          }
        }
      } else {
          Logger.log("Dashboard: Nenhuma manutenção encontrada.");
      }


      // --- Processamento Aba Equipamentos ---
      if (dadosEquipamentos.length > 1) {
        var cabecalhosE = dadosEquipamentos[0].map(h=>String(h).trim());
        var idxStatusE = cabecalhosE.indexOf('Status');

        if (idxStatusE !== -1) {
          statusEquipamentosGeral.total = dadosEquipamentos.length - 1; // Total de equipamentos cadastrados
          for (var i = 1; i < dadosEquipamentos.length; i++) {
            var statusE = String(dadosEquipamentos[i][idxStatusE]).trim();
            switch (statusE) {
              case "Disponível": statusEquipamentosGeral.disponivel++; break;
              case "Em Manutenção": statusEquipamentosGeral.em_manutencao++; break;
              case "Aguardando Manutenção": statusEquipamentosGeral.aguardando++; break;
              case "Desativado": statusEquipamentosGeral.desativado++; break;
              default:
                if (statusE) statusEquipamentosGeral.outros++; // Conta como outros se tiver algum status não mapeado
                else statusEquipamentosGeral.total--; // Se status for vazio, não conta como equipamento válido? Ou conta como 'outros'? Decisão: Diminuir total.
                break;
            }
          }
        } else {
           Logger.log("Dashboard: Coluna 'Status' não encontrada em Equipamentos.");
           statusEquipamentosGeral.total = dadosEquipamentos.length - 1; // Ainda conta o total
        }
      } else {
           Logger.log("Dashboard: Nenhum equipamento encontrado.");
      }

      // --- Processamento Aba Histórico ---
       if (dadosHistorico.length > 1) {
           var cabecalhosH = dadosHistorico[0].map(h=>String(h).trim());
           var idxDataH = cabecalhosH.indexOf('Data');
           var idxPlacaH = cabecalhosH.indexOf('Placa');
           var idxStatusAntH = cabecalhosH.indexOf('Status_Anterior');
           var idxStatusNovoH = cabecalhosH.indexOf('Status_Novo');

           if ([idxDataH, idxPlacaH, idxStatusAntH, idxStatusNovoH].includes(-1)) {
                Logger.log("Dashboard: Colunas essenciais não encontradas no Histórico.");
           } else {
               // Pega as últimas 7 entradas do histórico
               var limiteAtividade = Math.min(dadosHistorico.length - 1, 7);
               for(var i = dadosHistorico.length - 1; i > dadosHistorico.length - 1 - limiteAtividade; i--){
                    if(i <= 0) break; // Evita acessar índice 0 ou negativo
                    var linhaH = dadosHistorico[i];
                    var dataH = linhaH[idxDataH] instanceof Date ? linhaH[idxDataH] : null;
                    if (dataH) { // Só adiciona se tiver data válida
                        atividadeRecenteHistorico.push({
                           data: dataH.toISOString(),
                           placa: String(linhaH[idxPlacaH]).trim() || 'N/A',
                           statusAnterior: String(linhaH[idxStatusAntH]).trim() || '-',
                           statusNovo: String(linhaH[idxStatusNovoH]).trim() || 'N/A',
                           // Opcional: adicionar responsável e observação se precisar
                           // responsavel: String(linhaH[cabecalhosH.indexOf('Responsavel')]).trim() || '-',
                           // observacao: String(linhaH[cabecalhosH.indexOf('Observacao')]).trim() || '-'
                        });
                    }
               }
               // A ordem já será decrescente por causa do loop de trás para frente
           }
       } else {
           Logger.log("Dashboard: Nenhum histórico encontrado.");
       }

      // --- Finalização e Cálculo de Médias ---
      var tempoMedioFinal = {};
      for (var tipo in tempoMedioResolucaoPorTipo) {
        if (tempoMedioResolucaoPorTipo[tipo].contagem > 0) {
          tempoMedioFinal[tipo] = {
            mediaHoras: tempoMedioResolucaoPorTipo[tipo].totalHoras / tempoMedioResolucaoPorTipo[tipo].contagem,
            contagem: tempoMedioResolucaoPorTipo[tipo].contagem
          };
        }
      }

      // --- Montagem do Objeto de Retorno ---
      return {
        success: true,
        dados: {
          contadoresManutencoes: {
            status: contadoresStatusManut,
            categoriaProblema: contadoresCategoriaProblema,
            tipoEquipamento: contadoresTipoEquipManut
          },
          statusEquipamentos: statusEquipamentosGeral,
          tempoMedioResolucaoPorTipo: tempoMedioFinal,
          manutencoesRecentes: manutencoesRecentes, // Já está ordenado pelas mais recentes
          atividadeRecente: atividadeRecenteHistorico // Já está ordenado pelas mais recentes
        }
      };
    } catch (e) {
      Logger.log(`Erro CRÍTICO em obterDadosDashboard: ${e.message}\n${e.stack}`);
      return { success: false, message: "Erro ao gerar dados do dashboard: " + e.message };
    }
}


/** Obtém a contagem de manutenções por dia para o gráfico de período. */
function obterManutencoesPorPeriodo(diasParam) {
   try {
     var dias = parseInt(diasParam) || 30; // Default para 30 dias se não especificado ou inválido
     if (dias <= 0 || dias > 365) dias = 30; // Limita o período para evitar sobrecarga

     // Define a data inicial do período
     var dataFim = new Date(); // Hoje
     var dataInicio = new Date();
     dataInicio.setDate(dataFim.getDate() - (dias - 1)); // Subtrai (dias - 1) para incluir hoje
     dataInicio.setHours(0, 0, 0, 0); // Começo do dia inicial
     dataFim.setHours(23, 59, 59, 999); // Fim do dia final para incluir tudo de hoje

     // Logger.log(`Gerando contagem de manutenções por período: ${dias} dias (de ${Utilities.formatDate(dataInicio, Session.getScriptTimeZone(), 'yyyy-MM-dd')} a ${Utilities.formatDate(dataFim, Session.getScriptTimeZone(), 'yyyy-MM-dd')})`);


     var plan = obterPlanilha();
     var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
     if (!abaM) return { success: false, message: `Aba '${NOME_PLANILHA_MANUTENCOES}' não encontrada.` };

     var dados = abaM.getDataRange().getValues();
     var cabecalhos = dados[0].map(h => String(h).trim());
     var idxDataCriacao = cabecalhos.indexOf('Data_Criacao');

     if (idxDataCriacao === -1) return { success: false, message: "Coluna 'Data_Criacao' não encontrada na aba Manutenções." };

     // Inicializa o objeto de contagem com todas as datas do período com 0
     var contagemPorDia = {};
     var dataTemp = new Date(dataInicio);
     // Corrige loop para parar na data fim
     while(dataTemp <= dataFim) {
         let dataFormatada = Utilities.formatDate(dataTemp, Session.getScriptTimeZone(), 'yyyy-MM-dd');
         contagemPorDia[dataFormatada] = 0;
         dataTemp.setDate(dataTemp.getDate() + 1); // Avança para o próximo dia
         // Segurança contra loop infinito (improvável, mas...)
         if (Object.keys(contagemPorDia).length > dias + 5) break;
     }


     // Itera pelas manutenções para contar
     for (var i = 1; i < dados.length; i++) {
       var dataCriacao = dados[i][idxDataCriacao];
       // Verifica se é uma data válida e se está dentro do período desejado
       if (dataCriacao instanceof Date && !isNaN(dataCriacao.getTime()) && dataCriacao >= dataInicio && dataCriacao <= dataFim) {
         var dataFormatada = Utilities.formatDate(dataCriacao, Session.getScriptTimeZone(), 'yyyy-MM-dd');
          // Incrementa a contagem para o dia correspondente
          // Verifica se a chave existe (deve existir por causa da inicialização)
          if (contagemPorDia.hasOwnProperty(dataFormatada)) {
             contagemPorDia[dataFormatada]++;
          } else {
              // Caso inesperado: data dentro do range mas não inicializada? Logar.
              Logger.log(`AVISO: Data ${dataFormatada} encontrada mas não estava no objeto inicializado.`);
              contagemPorDia[dataFormatada] = 1;
          }
       }
     }

     // Garante que apenas as datas dentro do período exato sejam retornadas
     const resultadoFinal = {};
     Object.keys(contagemPorDia).sort().forEach(dataKey => {
         try {
             const dataObjKey = new Date(dataKey + 'T00:00:00'); // Adiciona T00:00:00 para parse correto
             if(!isNaN(dataObjKey.getTime())) {
                 // Compara apenas dia/mês/ano
                  const inicioComp = new Date(dataInicio.getFullYear(), dataInicio.getMonth(), dataInicio.getDate());
                  const fimComp = new Date(dataFim.getFullYear(), dataFim.getMonth(), dataFim.getDate());
                  const keyComp = new Date(dataObjKey.getFullYear(), dataObjKey.getMonth(), dataObjKey.getDate());

                 if (keyComp >= inicioComp && keyComp <= fimComp) {
                     resultadoFinal[dataKey] = contagemPorDia[dataKey];
                 }
             }
         } catch(e) {
             Logger.log("Erro ao validar data chave no resultado final: " + dataKey);
         }
     });


     return { success: true, dados: resultadoFinal }; // Retorna o objeto { "yyyy-mm-dd": contagem }

   } catch (e) {
     Logger.log(`Erro em obterManutencoesPorPeriodo: ${e.message}\n${e.stack}`);
     return { success: false, message: "Erro ao obter dados por período: " + e.message };
   }
}


// ========================================================================
// Funções de Upload e Gerenciamento de Imagens
// ========================================================================

/**
 * Faz upload de uma imagem codificada em Base64 para uma pasta específica no Drive.
 * Cria uma subpasta para a manutenção se não existir.
 * @param {string} manutencaoId ID da manutenção (usado para nomear a subpasta).
 * @param {string} imagemBase64 String da imagem em Base64 (com prefixo data:image/...).
 * @returns {object} { success: boolean, url?: string, id?: string, message?: string }
 */
function uploadImagemBase64ParaDrive(manutencaoId, imagemBase64) {
  try {
    // Garante que a pasta raiz de imagens esteja configurada/obtida
    if (!PASTA_IMAGENS_ID) {
        const configPastaResult = configurarPastaImagens(); // Tenta configurar
        if (!configPastaResult.success || !PASTA_IMAGENS_ID) {
            throw new Error("Pasta raiz de imagens não configurada ou falha ao configurar: " + (configPastaResult.message || "Erro desconhecido"));
        }
    }

    var pastaRaiz = DriveApp.getFolderById(PASTA_IMAGENS_ID);
    var pastaManutencao;

    // Procura ou cria a subpasta para esta manutenção específica
    var pastasExistentes = pastaRaiz.getFoldersByName(manutencaoId);
    if (pastasExistentes.hasNext()) {
      pastaManutencao = pastasExistentes.next();
      // Logger.log(`Usando subpasta existente: ${pastaManutencao.getName()} (ID: ${pastaManutencao.getId()})`);
    } else {
      pastaManutencao = pastaRaiz.createFolder(manutencaoId);
      Logger.log(`Subpasta criada para manutenção ${manutencaoId} (ID: ${pastaManutencao.getId()})`);
    }

    // Decodifica a string Base64
    var match = imagemBase64.match(/^data:(image\/(.+));base64,(.*)$/);
    if (!match) throw new Error("Formato Base64 inválido. Prefixo 'data:image/...' não encontrado.");

    var mimeType = match[1]; // Ex: image/png
    var extensao = "." + (match[2] || 'png').split('+')[0]; // Pega a extensão (ou usa png como padrão), remove +xml etc.
    var dadosBase64 = match[3];
    var dadosDecodificados = Utilities.base64Decode(dadosBase64);

    // Cria o Blob e o arquivo no Drive
    var nomeArquivo = `img_${manutencaoId}_${Date.now()}${extensao}`; // Nome único com timestamp
    var blob = Utilities.newBlob(dadosDecodificados, mimeType, nomeArquivo);
    var arquivoSalvo = pastaManutencao.createFile(blob);

    // Define permissão de compartilhamento para que qualquer pessoa com o link possa ver
    // IMPORTANTE: Considerar implicações de segurança. Se as imagens forem sensíveis,
    // pode ser necessário um controle de acesso mais restrito.
    arquivoSalvo.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

    // Logger.log(`Imagem salva no Drive: ${arquivoSalvo.getName()}, ID: ${arquivoSalvo.getId()}, URL: ${arquivoSalvo.getUrl()}`);

    return {
        success: true,
        url: arquivoSalvo.getUrl(), // URL para visualização/download
        id: arquivoSalvo.getId()     // ID do arquivo no Drive
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO em uploadImagemBase64ParaDrive para ${manutencaoId}: ${e.message}\n${e.stack}`);
    return {
        success: false,
        message: `Erro durante o upload da imagem: ${e.message}`
    };
  }
}


/**
 * Função principal para lidar com upload de imagem via POST.
 * Recebe o Base64, chama uploadImagemBase64ParaDrive, e atualiza a planilha.
 * @param {string} manutencaoId ID da manutenção a associar a imagem.
 * @param {string} imagemBase64 String Base64 da imagem.
 * @param {string} tipo 'pre' ou 'pos' para indicar se é imagem pré ou pós manutenção.
 * @param {string|null} idOriginalParaSubstituir Se fornecido, substitui a imagem com este ID.
 * @returns {object} Resultado da operação { success, message, url?, id?, timestamp? }
 */
function uploadImagem(manutencaoId, imagemBase64, tipo, idOriginalParaSubstituir = null) {
  var lock = LockService.getScriptLock();
  var lockAcquired = lock.tryLock(20000); // Lock para evitar conflito ao atualizar a planilha
   if (!lockAcquired) {
      Logger.log("uploadImagem: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente enviar a imagem novamente." };
   }

  try {
    if (!manutencaoId || !imagemBase64 || !tipo) {
      throw new Error("Parâmetros insuficientes para upload (ID da manutenção, imagem base64 e tipo são obrigatórios).");
    }
    if (tipo !== 'pre' && tipo !== 'pos') {
        throw new Error("Tipo de imagem inválido. Use 'pre' ou 'pos'.");
    }

    // 1. Faz o upload para o Drive
    const uploadResult = uploadImagemBase64ParaDrive(manutencaoId, imagemBase64);
    if (!uploadResult.success) {
      // Se o upload falhar, não continua
      throw new Error(uploadResult.message || "Falha no upload da imagem para o Drive.");
    }

    const { url: novaUrl, id: novoId } = uploadResult;
    const novoTimestamp = new Date().toISOString();
    const novaImagemObj = { url: novaUrl, id: novoId, timestamp: novoTimestamp };

    // 2. Obtém a manutenção atual para atualizar o array de imagens
    var resManut = obterManutencao(manutencaoId);
    if (!resManut.success || !resManut.manutencao) {
      // Se a manutenção não for encontrada APÓS o upload, o que fazer com a imagem órfã?
      // Opção 1: Excluir a imagem recém-criada.
      try { DriveApp.getFileById(novoId).setTrashed(true); } catch(delErr){ Logger.log(`AVISO: Falha ao excluir imagem órfã ${novoId} após manutenção ${manutencaoId} não encontrada: ${delErr}`);}
      throw new Error(`Manutenção ID ${manutencaoId} não encontrada após upload da imagem. Imagem órfã excluída.`);
      // Opção 2: Deixar a imagem e retornar erro (pode poluir o Drive).
      // throw new Error(`Manutenção ID ${manutencaoId} não encontrada após upload da imagem. Imagem ${novoId} ficou órfã.`);
    }

    var manut = resManut.manutencao;
    var nomeArrayImagens = tipo === 'pre' ? 'Imagens_Pre' : 'Imagens_Pos';
    // Garante que o campo existe e é um array, mesmo que estivesse mal formatado antes
    var arrayImagens = Array.isArray(manut[nomeArrayImagens]) ? manut[nomeArrayImagens] : [];

    // 3. Atualiza o array de imagens (substitui ou adiciona)
    if (idOriginalParaSubstituir) {
      var indexOriginal = arrayImagens.findIndex(img => img && img.id === idOriginalParaSubstituir);
      if (indexOriginal !== -1) {
        // Substitui a imagem antiga pela nova no array
        const imagemAntiga = arrayImagens[indexOriginal];
        arrayImagens[indexOriginal] = novaImagemObj;
        Logger.log(`Imagem ${novoId} substituindo ${idOriginalParaSubstituir} no array para ${manutencaoId}.`);
        // Tenta excluir o arquivo antigo do Drive
        try {
          DriveApp.getFileById(idOriginalParaSubstituir).setTrashed(true);
          Logger.log(`Arquivo antigo ${idOriginalParaSubstituir} movido para a lixeira.`);
        } catch (e) {
          Logger.log(`AVISO: Falha ao excluir arquivo antigo ${idOriginalParaSubstituir} do Drive durante substituição: ${e.message}`);
        }
      } else {
        // Se o ID original não foi encontrado no array, adiciona a nova imagem mesmo assim
        Logger.log(`AVISO: ID original ${idOriginalParaSubstituir} não encontrado no array de ${manutencaoId}. Adicionando nova imagem ${novoId}.`);
        arrayImagens.push(novaImagemObj);
      }
    } else {
      // Adiciona a nova imagem ao final do array
      arrayImagens.push(novaImagemObj);
       Logger.log(`Nova imagem ${novoId} adicionada ao array ${nomeArrayImagens} para ${manutencaoId}.`);
    }

    // 4. Salva o array atualizado de volta na planilha
    var plan = obterPlanilha();
    var abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
    var cabecalhos = abaM.getRange(1, 1, 1, abaM.getLastColumn()).getValues()[0].map(h=>h.trim());
    var resLinha = obterLinhaManutencaoPorId(abaM, cabecalhos, manutencaoId);

    if (!resLinha) {
       // Inconsistência grave se chegou até aqui
        throw new Error(`Falha ao encontrar a linha da manutenção ${manutencaoId} para salvar o array de imagens atualizado.`);
    }

    var linha = resLinha.linha;
    var imgColIdx = cabecalhos.indexOf(nomeArrayImagens);

    if (imgColIdx === -1) {
        throw new Error(`Coluna ${nomeArrayImagens} não encontrada na planilha.`);
    }

    // Salva o array como string JSON
    abaM.getRange(linha, imgColIdx + 1).setValue(JSON.stringify(arrayImagens));
    Logger.log(`Array ${nomeArrayImagens} atualizado na linha ${linha} para ${manutencaoId}.`);

    // 5. Retorna sucesso com os dados da nova imagem
    return {
      success: true,
      message: idOriginalParaSubstituir ? "Imagem substituída com sucesso!" : "Imagem salva com sucesso!",
      url: novaUrl,
      id: novoId,
      timestamp: novoTimestamp
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO em uploadImagem para ${manutencaoId}: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro durante o upload da imagem: " + e.message };
  } finally {
     if (lockAcquired) {
        lock.releaseLock();
     }
  }
}


/**
 * Exclui uma referência de imagem da planilha e o arquivo correspondente no Drive.
 * @param {string} idManutencao ID da manutenção.
 * @param {string} idImagem ID do arquivo da imagem no Drive a ser excluída.
 * @param {string} tipo 'pre' ou 'pos' para saber em qual array procurar.
 * @returns {object} { success: boolean, message: string }
 */
function excluirImagem(idManutencao, idImagem, tipo) {
  var lock = LockService.getScriptLock();
  var lockAcquired = lock.tryLock(15000);
   if (!lockAcquired) {
      Logger.log("excluirImagem: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente excluir a imagem novamente." };
   }

  try {
    if (!idManutencao || !idImagem || !tipo) throw new Error("Parâmetros insuficientes (ID Manutenção, ID Imagem, Tipo).");
    if (tipo !== 'pre' && tipo !== 'pos') throw new Error("Tipo inválido ('pre' ou 'pos').");

    Logger.log(`Tentando excluir imagem ${idImagem} (tipo ${tipo}) da manutenção ${idManutencao}.`);

    // 1. Tenta excluir o arquivo do Google Drive primeiro
    try {
      const file = DriveApp.getFileById(idImagem);
      file.setTrashed(true); // Move para a lixeira
      Logger.log(`Arquivo ${idImagem} (ref ${idManutencao}) movido para a lixeira no Drive.`);
    } catch (driveError) {
      // O arquivo pode não existir mais, ter permissão negada, etc.
      // Continua mesmo assim para remover a referência da planilha.
      Logger.log(`AVISO: Erro ao mover arquivo ${idImagem} (ref ${idManutencao}) para a lixeira: ${driveError.message}. Prosseguindo para remover referência da planilha.`);
    }

    // 2. Obtém a manutenção para acessar o array de imagens
    var resManut = obterManutencao(idManutencao);
    // Se a manutenção não existe, não há o que fazer na planilha.
    if (!resManut.success || !resManut.manutencao) {
        Logger.log(`Manutenção ${idManutencao} não encontrada para remover referência da imagem ${idImagem}.`);
        // Retorna sucesso, pois o objetivo principal (remover o arquivo) foi tentado.
        return { success: true, message: "Arquivo tentado excluir do Drive. Manutenção não encontrada para remover referência." };
    }

    var manut = resManut.manutencao;
    var nomeArray = tipo === 'pre' ? 'Imagens_Pre' : 'Imagens_Pos';
    var arrayImagens = Array.isArray(manut[nomeArray]) ? manut[nomeArray] : [];

    // 3. Encontra e remove a imagem do array
    var indexParaRemover = arrayImagens.findIndex(img => img && img.id === idImagem);

    if (indexParaRemover === -1) {
      Logger.log(`Referência da imagem ${idImagem} não encontrada no array ${nomeArray} da manutenção ${idManutencao}. Nenhuma alteração na planilha.`);
      // Retorna sucesso, pois a referência já não estava lá.
      return { success: true, message: "Arquivo tentado excluir do Drive. Referência não encontrada na planilha." };
    }

    // Remove o item do array
    arrayImagens.splice(indexParaRemover, 1);
    Logger.log(`Referência da imagem ${idImagem} removida do array ${nomeArray} para ${idManutencao}.`);

    // 4. Salva o array modificado de volta na planilha
    var plan = obterPlanilha();
    var aba = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);
    var cabecalhos = aba.getRange(1, 1, 1, aba.getLastColumn()).getValues()[0].map(h=>h.trim());
    var resLinha = obterLinhaManutencaoPorId(aba, cabecalhos, idManutencao);

    if (!resLinha) throw new Error(`Inconsistência: Linha ${idManutencao} não encontrada para salvar array de imagens após remoção.`);

    var linha = resLinha.linha;
    var colIdx = cabecalhos.indexOf(nomeArray);

    if (colIdx === -1) throw new Error(`Coluna ${nomeArray} não encontrada para salvar array de imagens.`);

    aba.getRange(linha, colIdx + 1).setValue(JSON.stringify(arrayImagens));
    Logger.log(`Array ${nomeArray} atualizado na planilha (linha ${linha}) após exclusão da imagem ${idImagem}.`);

    return { success: true, message: "Imagem excluída com sucesso (arquivo e referência)." };

  } catch (e) {
    Logger.log(`Erro CRÍTICO em excluirImagem ${idManutencao}/${idImagem}: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao excluir imagem: " + e.message };
  } finally {
     if (lockAcquired) {
        lock.releaseLock();
     }
  }
}


// ========================================================================
// Funções de Relatórios (Geração de Arquivos)
// ========================================================================

/**
 * Gera um PDF simples (baseado em texto) de um relatório de manutenção e salva no Drive.
 * @param {string} id ID da Manutenção.
 * @returns {object} { success, message, url?, fileId? }
 */
function gerarPDFTextoBackend(id) {
  try {
    if (!id) throw new Error("ID da manutenção não fornecido.");

    // 1. Gera o conteúdo de texto do relatório
    var resTxt = gerarRelatorioManutencaoTexto(id);
    if (!resTxt.success) {
      // Repassa a mensagem de erro da função interna
      return { success: false, message: resTxt.message || "Falha ao gerar conteúdo do relatório." };
    }

    var textoRelatorio = resTxt.relatorio;
    var nomeArquivo = "Relatorio_Manutencao_" + id + ".pdf";

    // 2. Garante que a pasta de destino exista e obtém o ID
    if (!PASTA_IMAGENS_ID) {
        const configPastaResult = configurarPastaImagens();
        if (!configPastaResult.success || !PASTA_IMAGENS_ID) {
            throw new Error("Pasta de destino para PDF não configurada: " + (configPastaResult.message || "Erro desconhecido"));
        }
    }
    var pastaDestino = DriveApp.getFolderById(PASTA_IMAGENS_ID);

    // 3. Cria o Blob de texto e converte para PDF
    // Usar UTF-8 pode ajudar com caracteres especiais
    var blobTexto = Utilities.newBlob(textoRelatorio, MimeType.PLAIN_TEXT, nomeArquivo.replace('.pdf','.txt')).setDataFromString(textoRelatorio, 'UTF-8');
    var blobPDF = blobTexto.getAs(MimeType.PDF).setName(nomeArquivo);

    // 4. Salva o arquivo PDF na pasta de destino
    var arquivoPDF = pastaDestino.createFile(blobPDF);

    // 5. Define permissão de visualização pelo link
    arquivoPDF.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

    Logger.log(`PDF (texto) gerado e salvo: ${arquivoPDF.getName()}, ID: ${arquivoPDF.getId()}`);

    return {
        success: true,
        message: "Relatório PDF (baseado em texto) gerado com sucesso.",
        url: arquivoPDF.getUrl(),
        fileId: arquivoPDF.getId()
    };

  } catch (e) {
    Logger.log(`Erro em gerarPDFTextoBackend para ID ${id}: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao gerar PDF básico: " + e.message };
  }
}

/**
 * Gera o conteúdo em formato de texto plano de um relatório de manutenção.
 * @param {string} id ID da Manutenção.
 * @returns {object} { success: boolean, relatorio?: string, message?: string }
 */
function gerarRelatorioManutencaoTexto(id) {
  try {
    if (!id) return { success: false, message: "ID da manutenção não fornecido." };

    var res = obterManutencao(id);
    if (!res.success || !res.manutencao) {
      return { success: false, message: res.message || `Manutenção ID ${id} não encontrada.` };
    }

    var m = res.manutencao; // m contém o objeto da manutenção
    var txt = ""; // String para construir o relatório
    var separador = "=".repeat(70) + "\n";
    var sublinhado = "-".repeat(70) + "\n";

    // Cabeçalho
    txt += separador;
    txt += "           RELATÓRIO DE MANUTENÇÃO\n";
    txt += separador + "\n";

    // Informações Gerais
    txt += `ID: ${m.ID}\n`;
    txt += `Data Abertura: ${formatarData(m.Data_Criacao)}\n`;
    txt += `Status Atual: ${m.Status}\n\n`;

    // Equipamento
    txt += "EQUIPAMENTO\n";
    txt += sublinhado;
    txt += `Placa: ${m.Placa || 'N/A'}\n`;
    txt += `Modelo: ${m.Modelo || 'N/A'}\n`;
    txt += `Tipo: ${m.Tipo_Equipamento || 'N/A'}\n\n`;

    // Problema Reportado
    txt += "PROBLEMA\n";
    txt += sublinhado;
    txt += `Categoria: ${m.Categoria_Problema || 'N/A'}\n`;
    txt += `Urgência: ${m.Urgencia || 'N/A'}\n`;
    txt += `Descrição: ${m.Descricao_Problema || 'N/A'}\n`;
    if (m.Motivo_Outro) txt += `Detalhe (Outro): ${m.Motivo_Outro}\n`;
    txt += "\n";

    // Seção Pré-Manutenção
    txt += "PRÉ-MANUTENÇÃO\n";
    txt += sublinhado;
    txt += "Checklist Pré:\n";
    var checklistPre = m.Checklist_Pre || {}; // Garante que é objeto
    if (Object.keys(checklistPre).length > 0) {
      for (var item in checklistPre) {
        txt += ` - ${item}: ${checklistPre[item]}\n`;
      }
    } else {
      txt += "(Nenhum item de checklist registrado)\n";
    }
    txt += `Observações Pré: ${m.Observacoes_Pre || "(Nenhuma)"}\n`;
    // Lista de Imagens Pré (opcional, apenas IDs ou nomes)
    var imagensPre = m.Imagens_Pre || [];
    if (Array.isArray(imagensPre) && imagensPre.length > 0) {
        txt += "Imagens Pré: \n";
        imagensPre.forEach(img => txt += ` - ID: ${img.id || 'N/A'} (Adicionada em: ${formatarData(img.timestamp || null)})\n`);
    } else {
        txt += "Imagens Pré: (Nenhuma)\n";
    }
    txt += "\n";


    // Seção Pós-Manutenção (se concluída/disponível ou tiver data)
    if (m.Status === STATUS_CONCLUIDO || m.Status === STATUS_DISPONIVEL || m.Data_Manutencao) {
      txt += "PÓS-MANUTENÇÃO\n";
      txt += sublinhado;
      txt += `Data Conclusão: ${formatarData(m.Data_Manutencao)}\n`; // Mostra N/A se não tiver data
      txt += "Checklist Pós:\n";
      var checklistPos = m.Checklist_Pos || {};
      if (Object.keys(checklistPos).length > 0) {
        for (var itemPos in checklistPos) {
          txt += ` - ${itemPos}: ${checklistPos[itemPos]}\n`;
        }
      } else {
        txt += "(Nenhum item de checklist registrado)\n";
      }
      txt += `Observações Pós: ${m.Observacoes_Pos || "(Nenhuma)"}\n`;
      // Lista de Imagens Pós
      var imagensPos = m.Imagens_Pos || [];
      if (Array.isArray(imagensPos) && imagensPos.length > 0) {
          txt += "Imagens Pós: \n";
          imagensPos.forEach(img => txt += ` - ID: ${img.id || 'N/A'} (Adicionada em: ${formatarData(img.timestamp || null)})\n`);
      } else {
          txt += "Imagens Pós: (Nenhuma)\n";
      }
      txt += "\n";
    }

    // Rodapé
    txt += `Responsável (Últ. Edição): ${m.Responsavel || 'N/A'}\n`;
    txt += `Última Atualização no Sistema: ${formatarData(m.Data_Atualizacao)}\n\n`;
    txt += separador;
    txt += `Relatório gerado em ${formatarData(new Date())} - Sistema v${VERSAO_APP}\n`;
    txt += separador;

    return { success: true, relatorio: txt };

  } catch (e) {
    Logger.log(`Erro em gerarRelatorioManutencaoTexto para ID ${id}: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao gerar conteúdo do relatório de texto: " + e.message };
  }
}


/**
 * Ponto de entrada para gerar relatórios avançados (PDF, Excel, CSV).
 * @param {string} id ID da Manutenção.
 * @param {string} [formato='pdf'] Formato desejado ('pdf', 'excel', 'csv').
 * @param {object} [opcoes={}] Opções adicionais (ex: incluirImagens, etc. - não implementado ainda).
 * @returns {object} { success, message, url?, fileId? }
 */
function gerarRelatorioAvancado(id, formato = 'pdf', opcoes = {}) {
  try {
    if (!id) throw new Error("ID da manutenção não fornecido.");

    // 1. Obter dados da manutenção principal
    const resManut = obterManutencao(id);
    if (!resManut.success || !resManut.manutencao) {
      return { success: false, message: resManut.message || `Manutenção ID ${id} não encontrada.` };
    }
    const manutencao = resManut.manutencao;

    // 2. Obter histórico da manutenção
    const resHist = obterHistoricoManutencao(id);
    // Não trata como erro fatal se o histórico não for encontrado, apenas loga.
    if (!resHist.success) {
        Logger.log(`AVISO: Falha ao obter histórico para ${id}: ${resHist.message}. Relatório será gerado sem histórico.`);
    }
    const historico = resHist.success ? resHist.historico : []; // Usa array vazio se falhar

    // 3. Garante que a pasta de destino exista
     if (!PASTA_IMAGENS_ID) {
        const configPastaResult = configurarPastaImagens();
        if (!configPastaResult.success || !PASTA_IMAGENS_ID) {
            throw new Error("Pasta de destino para Relatório Avançado não configurada: " + (configPastaResult.message || "Erro desconhecido"));
        }
    }

    // 4. Chama a função específica para o formato solicitado
    switch (String(formato).toLowerCase()) {
      case 'pdf':
        Logger.log(`Gerando relatório PDF Avançado para ${id}`);
        return gerarRelatorioPDFAvancado(manutencao, historico, opcoes);
      case 'excel':
        Logger.log(`Gerando relatório Excel para ${id}`);
        return gerarRelatorioExcel(manutencao, historico, opcoes);
      case 'csv':
         Logger.log(`Gerando relatório CSV para ${id}`);
        return gerarRelatorioCSV(manutencao, historico, opcoes);
      default:
        Logger.log(`Formato de relatório avançado não suportado: ${formato}`);
        return { success: false, message: `Formato de relatório '${formato}' não suportado. Use 'pdf', 'excel' ou 'csv'.` };
    }
  } catch (error) {
    Logger.log(`Erro CRÍTICO em gerarRelatorioAvancado para ID ${id} (Formato: ${formato}): ${error.message}\n${error.stack}`);
    return { success: false, message: "Erro inesperado ao gerar relatório avançado: " + error.message };
  }
}


/**
 * Obtém o histórico de alterações de uma manutenção específica.
 * @param {string} id ID da Manutenção.
 * @returns {object} { success: boolean, historico?: Array<object>, message?: string }
 */
function obterHistoricoManutencao(id) {
  try {
    if (!id) return { success: false, message: "ID da manutenção não fornecido para buscar histórico." };

    const plan = obterPlanilha();
    const abaH = plan.getSheetByName(NOME_PLANILHA_HISTORICO);

    if (!abaH) return { success: false, message: `Aba de Histórico ('${NOME_PLANILHA_HISTORICO}') não encontrada.` };

    const dados = abaH.getDataRange().getValues();
    if (dados.length <= 1) return { success: true, historico: [] }; // Histórico vazio

    const cabecalhos = dados[0].map(h => String(h).trim());
    const idColIdx = cabecalhos.indexOf('ID_Manutencao');

    if (idColIdx === -1) return { success: false, message: "Coluna 'ID_Manutencao' não encontrada na aba Histórico."};

    const historicoFiltrado = [];
    // Itera pelos dados do histórico
    for (let i = 1; i < dados.length; i++) {
      if (String(dados[i][idColIdx]).trim() === String(id).trim()) {
        // Encontrou um registro para a manutenção, mapeia para objeto
        const itemHistorico = {};
        cabecalhos.forEach((header, idx) => {
          if (!header) return; // Pula coluna sem cabeçalho
          let valor = dados[i][idx];
          // Formata data para ISO string
          if (header === 'Data' && valor instanceof Date && !isNaN(valor.getTime())) {
            valor = valor.toISOString();
          } else {
            // Garante que outros valores sejam strings
            valor = valor !== undefined && valor !== null ? String(valor) : "";
          }
          itemHistorico[header] = valor;
        });
        historicoFiltrado.push(itemHistorico);
      }
    }

    // Ordena o histórico pela data (mais recente primeiro)
    historicoFiltrado.sort((a, b) => {
        let dateA = 0; try { dateA = new Date(a.Data).getTime(); if(isNaN(dateA)) dateA=0; } catch(e){}
        let dateB = 0; try { dateB = new Date(b.Data).getTime(); if(isNaN(dateB)) dateB=0; } catch(e){}
        return dateB - dateA; // Decrescente
    });

    return { success: true, historico: historicoFiltrado };

  } catch (error) {
    Logger.log(`Erro em obterHistoricoManutencao para ID ${id}: ${error.message}\n${error.stack}`);
    return { success: false, message: "Erro ao obter histórico da manutenção: " + error.message };
  }
}


/**
 * Gera um relatório PDF mais elaborado usando HTML como base.
 * @param {object} manutencao Objeto com os dados da manutenção.
 * @param {Array<object>} historico Array com os itens do histórico.
 * @param {object} [opcoes={}] Opções (ex: incluirImagens).
 * @returns {object} { success, message, url?, fileId? }
 */
function gerarRelatorioPDFAvancado(manutencao, historico = [], opcoes = {}) {
  try {
    const folder = DriveApp.getFolderById(PASTA_IMAGENS_ID); // Assume que PASTA_IMAGENS_ID está definido
    const nomeArqBase = `Relatorio_Avanc_${manutencao.ID}_${Utilities.formatDate(new Date(),Session.getScriptTimeZone(),"yyyyMMdd")}`;
    const nomeArqPDF = nomeArqBase + ".pdf";
    const nomeArqHTML = nomeArqBase + ".html"; // Fallback

    // --- Construção do HTML ---
    // Estilos CSS inline ou em <style>
    // Tentar usar CSS simples para maior compatibilidade com a conversão para PDF do Apps Script
    let html = `<html><head><meta charset="utf-8"><title>Relatório ${manutencao.ID}</title><style>
        body { font-family: Arial, sans-serif; font-size: 10pt; margin: 20px; }
        h1 { text-align: center; color: #333; font-size: 16pt; border-bottom: 2px solid #ccc; padding-bottom: 5px; margin-bottom: 20px;}
        h2 { color: #0056b3; font-size: 12pt; margin-top: 20px; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 3px;}
        .secao { margin-bottom: 15px; page-break-inside: avoid; /* Tenta evitar quebra de página dentro da seção */}
        .info-item { margin-bottom: 6px; line-height: 1.4; }
        .destaque { font-weight: bold; color: #444; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; margin-bottom: 10px; page-break-inside: auto; }
        th, td { border: 1px solid #ccc; padding: 5px; text-align: left; font-size: 9pt; vertical-align: top; word-wrap: break-word; }
        th { background-color: #f2f2f2; font-weight: bold; }
        .checklist-item { margin-left: 15px; margin-bottom: 3px; font-size: 9pt; }
        .checklist-item .item {font-weight: bold;}
        .checklist-item .valor-ok { color: green; }
        .checklist-item .valor-nok { color: red; }
        .imagens-container { margin-top: 10px; }
        .imagem-item { display: inline-block; /* Tentar inline-block */ margin: 5px; text-align: center; vertical-align: top; width: 120px; /* Largura fixa pode ajudar */ page-break-inside: avoid; }
        .imagem-item img { max-width: 100px; max-height: 100px; border: 1px solid #ccc; margin-bottom: 3px; }
        .imagem-item small { font-size: 8pt; color: #777; display: block; }
        .historico-obs { font-style: italic; color: #555;}
        .footer { text-align: center; margin-top: 30px; font-size: 8pt; color: #999; border-top: 1px solid #eee; padding-top: 10px;}
        @media print { /* Estilos específicos para impressão/PDF */
           h1, h2, table, .secao { page-break-after: auto; page-break-inside: avoid; }
           img { max-width: 100% !important; height: auto; } /* Garante que imagens não estourem a página */
        }
    </style></head><body>`;

    html += `<h1>Relatório de Manutenção</h1>`;

    // Seção Geral
    html += `<div class="secao"><h2>Dados Gerais</h2>
               <div class="info-item"><span class="destaque">ID Manutenção:</span> ${manutencao.ID}</div>
               <div class="info-item"><span class="destaque">Data de Abertura:</span> ${formatarData(manutencao.Data_Criacao)}</div>
               <div class="info-item"><span class="destaque">Status Atual:</span> ${manutencao.Status}</div>
               <div class="info-item"><span class="destaque">Responsável (Últ. Edição):</span> ${manutencao.Responsavel || 'N/A'}</div>
               <div class="info-item"><span class="destaque">Última Atualização:</span> ${formatarData(manutencao.Data_Atualizacao)}</div>
             </div>`;

    // Seção Equipamento
    html += `<div class="secao"><h2>Equipamento</h2>
               <div class="info-item"><span class="destaque">Placa:</span> ${manutencao.Placa || 'N/A'}</div>
               <div class="info-item"><span class="destaque">Modelo:</span> ${manutencao.Modelo || 'N/A'}</div>
               <div class="info-item"><span class="destaque">Tipo:</span> ${manutencao.Tipo_Equipamento || 'N/A'}</div>
             </div>`;

    // Seção Problema
    html += `<div class="secao"><h2>Problema Reportado</h2>
               <div class="info-item"><span class="destaque">Categoria:</span> ${manutencao.Categoria_Problema || 'N/A'}</div>
               <div class="info-item"><span class="destaque">Urgência:</span> ${manutencao.Urgencia || 'N/A'}</div>
               <div class="info-item"><span class="destaque">Descrição:</span> ${manutencao.Descricao_Problema || 'N/A'}</div>
               ${manutencao.Motivo_Outro ? `<div class="info-item"><span class="destaque">Detalhe (Outro):</span> ${manutencao.Motivo_Outro}</div>` : ''}
             </div>`;

    // Função auxiliar para renderizar Checklist
    const renderChecklistHTML = (checklistObj) => {
      if (!checklistObj || typeof checklistObj !== 'object' || Object.keys(checklistObj).length === 0) {
        return '<div class="checklist-item">(Nenhum item registrado)</div>';
      }
      let checklistHTML = '';
      for (const item in checklistObj) {
        let valor = checklistObj[item];
        let classeValor = '';
        // Tenta aplicar estilo baseado no valor (ajuste conforme seus valores padrão)
        if (String(valor).toUpperCase() === 'OK' || String(valor).toUpperCase() === 'CONFORME') classeValor = 'valor-ok';
        else if (String(valor).toUpperCase() === 'NOK' || String(valor).toUpperCase() === 'NÃO CONFORME' || String(valor).toUpperCase() === 'DANIFICADO') classeValor = 'valor-nok';
        checklistHTML += `<div class="checklist-item"><span class="item">${item}:</span> <span class="${classeValor}">${valor}</span></div>`;
      }
      return checklistHTML;
    };

    // Função auxiliar para renderizar Imagens (usando links diretos para PDF)
    const renderImagensHTML = (imagensArray, tipoLabel) => {
        if (!Array.isArray(imagensArray) || imagensArray.length === 0) {
            return '<p>(Nenhuma imagem)</p>';
        }
        let imagensHTML = `<div class="imagens-container">`;
        imagensArray.forEach((img, index) => {
            if (img && img.id && img.url) {
                // Para PDF, usar o link direto é mais confiável e leve
                let imgTag = `<a href="${img.url}" target="_blank"><img src="${img.url}" alt="Imagem ${tipoLabel} ${index+1}"></a>`;

                imagensHTML += `<div class="imagem-item">
                                ${imgTag}
                                <small>ID: ${img.id}<br>Adicionada: ${formatarData(img.timestamp)}</small>
                              </div>`;
            } else {
                 imagensHTML += `<div class="imagem-item"><span>[Imagem inválida]</span></div>`;
            }
        });
        imagensHTML += '</div>';
        return imagensHTML;
    };

    // Seção Pré-Manutenção
    html += `<div class="secao"><h2>Pré-Manutenção</h2>
               <div class="info-item"><span class="destaque">Checklist Pré:</span>${renderChecklistHTML(manutencao.Checklist_Pre)}</div>
               <div class="info-item"><span class="destaque">Observações Pré:</span> ${manutencao.Observacoes_Pre || '(Nenhuma)'}</div>
               <div class="info-item"><span class="destaque">Imagens Pré:</span>${renderImagensHTML(manutencao.Imagens_Pre, 'Pre')}</div>
             </div>`;

    // Seção Pós-Manutenção (se aplicável)
    if (manutencao.Status === STATUS_CONCLUIDO || manutencao.Status === STATUS_DISPONIVEL || manutencao.Data_Manutencao) {
       html += `<div class="secao"><h2>Pós-Manutenção</h2>
                  <div class="info-item"><span class="destaque">Data Conclusão:</span> ${formatarData(manutencao.Data_Manutencao)}</div>
                  <div class="info-item"><span class="destaque">Checklist Pós:</span>${renderChecklistHTML(manutencao.Checklist_Pos)}</div>
                  <div class="info-item"><span class="destaque">Observações Pós:</span> ${manutencao.Observacoes_Pos || '(Nenhuma)'}</div>
                   <div class="info-item"><span class="destaque">Imagens Pós:</span>${renderImagensHTML(manutencao.Imagens_Pos, 'Pos')}</div>
                </div>`;
    }

    // Seção Histórico (se houver)
    if (historico && historico.length > 0) {
      html += `<div class="secao"><h2>Histórico de Alterações</h2><table>
                 <thead><tr><th>Data</th><th>Status Anterior</th><th>Status Novo</th><th>Responsável</th><th>Observação</th></tr></thead>
                 <tbody>`;
      historico.forEach(item => {
        html += `<tr>
                   <td>${formatarData(item.Data)}</td>
                   <td>${item.Status_Anterior || '-'}</td>
                   <td>${item.Status_Novo}</td>
                   <td>${item.Responsavel || '-'}</td>
                   <td class="historico-obs">${item.Observacao || '-'}</td>
                 </tr>`;
      });
      html += `</tbody></table></div>`;
    }

    // Rodapé
    html += `<div class="footer">Relatório gerado automaticamente pelo Sistema de Manutenção v${VERSAO_APP} em ${formatarData(new Date())}</div>`;
    html += `</body></html>`;

    // --- Geração do Arquivo ---
    let file;
    try {
        // Tenta criar o PDF a partir do HTML
        // A conversão pode ter limitações com CSS complexo ou imagens externas dependendo das permissões
        const pdfBlob = Utilities.newBlob(html, MimeType.HTML).getAs(MimeType.PDF).setName(nomeArqPDF);
        file = folder.createFile(pdfBlob);
        Logger.log(`PDF Avançado gerado: ${file.getName()} (ID: ${file.getId()})`);
    } catch (pdfError) {
        // Se a conversão para PDF falhar
        Logger.log(`Falha ao converter HTML para PDF para ${manutencao.ID}: ${pdfError}. Tentando salvar como HTML.`);
        try {
            // Salva o arquivo como HTML como fallback
            const htmlBlob = Utilities.newBlob(html, MimeType.HTML, nomeArqHTML);
            file = folder.createFile(htmlBlob);
            Logger.log(`Relatório salvo como HTML (fallback): ${file.getName()} (ID: ${file.getId()})`);
            // Retorna sucesso, mas avisa que é HTML
             file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
             return {
                 success: true,
                 url: file.getUrl(),
                 fileId: file.getId(),
                 message: "Relatório gerado como HTML (falha na conversão para PDF)."
             };
        } catch (htmlError) {
             Logger.log(`Falha ao salvar como HTML também para ${manutencao.ID}: ${htmlError}`);
             throw new Error("Falha ao gerar PDF e também ao salvar como HTML: " + htmlError.message);
        }
    }

    // Define permissão no arquivo PDF gerado
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

    return {
        success: true,
        url: file.getUrl(),
        fileId: file.getId(),
        message: "Relatório PDF Avançado gerado com sucesso."
    };

  } catch (error) {
    Logger.log(`Erro CRÍTICO em gerarRelatorioPDFAvancado para ID ${manutencao ? manutencao.ID : 'N/A'}: ${error.message}\n${error.stack}`);
    return { success: false, message: "Erro interno ao gerar PDF avançado: " + error.message };
  }
}


/**
 * Gera um relatório em formato Excel (.xlsx).
 * @param {object} manutencao Objeto com os dados da manutenção.
 * @param {Array<object>} historico Array com os itens do histórico.
 * @param {object} [opcoes={}] Opções (não utilizado no momento).
 * @returns {object} { success, message, url?, fileId? }
 */
function gerarRelatorioExcel(manutencao, historico = [], opcoes = {}) {
    let fileIdTemp = null; // Para garantir a limpeza em caso de erro
    try {
        const folder = DriveApp.getFolderById(PASTA_IMAGENS_ID); // Pasta de destino
        const nomeArquivo = `Relatorio_${manutencao.ID}_${Utilities.formatDate(new Date(),Session.getScriptTimeZone(),"yyyyMMdd_HHmm")}.xlsx`;

        // 1. Cria uma nova Planilha Google temporária
        const ssTemp = SpreadsheetApp.create(`Temp_Excel_${manutencao.ID}_${Date.now()}`);
        fileIdTemp = ssTemp.getId(); // Guarda o ID para limpeza

        // --- Aba Detalhes ---
        const abaDetalhes = ssTemp.getActiveSheet().setName("Detalhes"); // Renomeia a primeira aba

        // Estilos (opcional, mas melhora a aparência)
        const boldStyle = SpreadsheetApp.newTextStyle().setBold(true).build();
        const headerBg = '#E8F0FE'; // Azul claro
        const sectionBg = '#F5F5F5'; // Cinza claro

        let linhaAtual = 1;

        // Título
        abaDetalhes.getRange(linhaAtual, 1, 1, 2).merge().setValue("Relatório de Manutenção").setFontSize(14).setTextStyle(boldStyle).setHorizontalAlignment('center');
        linhaAtual += 2; // Pula uma linha

        // Função auxiliar para adicionar linha de dados (Chave/Valor)
        const adicionarLinhaInfo = (chave, valor, estiloChave = boldStyle) => {
            const rangeChave = abaDetalhes.getRange(linhaAtual, 1).setValue(chave);
            if(estiloChave) rangeChave.setTextStyle(estiloChave);
            // Trata valor de data
            if (valor instanceof Date && !isNaN(valor.getTime())) {
                 abaDetalhes.getRange(linhaAtual, 2).setValue(valor).setNumberFormat('dd/mm/yyyy hh:mm');
            } else if (typeof valor === 'string' && (chave.startsWith('Data ') || chave.startsWith('Última '))) {
                // Se for string de data já formatada, apenas insere
                 abaDetalhes.getRange(linhaAtual, 2).setValue(valor).setNumberFormat('@'); // Formata como texto
            }
            else {
                abaDetalhes.getRange(linhaAtual, 2).setValue(valor);
            }
            linhaAtual++;
        };
         // Função auxiliar para adicionar linha de seção
        const adicionarLinhaSecao = (titulo) => {
             abaDetalhes.getRange(linhaAtual, 1, 1, 2).merge().setValue(titulo).setTextStyle(boldStyle).setBackground(sectionBg).setHorizontalAlignment('center');
             linhaAtual++;
        };

        // Dados Gerais
        adicionarLinhaSecao("Dados Gerais");
        adicionarLinhaInfo("ID Manutenção:", manutencao.ID);
        adicionarLinhaInfo("Data Abertura:", formatarData(manutencao.Data_Criacao));
        adicionarLinhaInfo("Status Atual:", manutencao.Status);
        adicionarLinhaInfo("Responsável (Últ. Edição):", manutencao.Responsavel || 'N/A');
        adicionarLinhaInfo("Última Atualização:", formatarData(manutencao.Data_Atualizacao));
        linhaAtual++; // Espaço

        // Equipamento
        adicionarLinhaSecao("Equipamento");
        adicionarLinhaInfo("Placa:", manutencao.Placa || 'N/A');
        adicionarLinhaInfo("Modelo:", manutencao.Modelo || 'N/A');
        adicionarLinhaInfo("Tipo:", manutencao.Tipo_Equipamento || 'N/A');
        linhaAtual++;

        // Problema
        adicionarLinhaSecao("Problema Reportado");
        adicionarLinhaInfo("Categoria:", manutencao.Categoria_Problema || 'N/A');
        adicionarLinhaInfo("Urgência:", manutencao.Urgencia || 'N/A');
        adicionarLinhaInfo("Descrição:", manutencao.Descricao_Problema || 'N/A', null); // Descrição sem negrito na chave
        abaDetalhes.getRange(linhaAtual - 1, 2).setWrap(true); // Quebra de linha na descrição
        if (manutencao.Motivo_Outro) {
            adicionarLinhaInfo("Detalhe (Outro):", manutencao.Motivo_Outro, null);
            abaDetalhes.getRange(linhaAtual - 1, 2).setWrap(true);
        }
        linhaAtual++;

        // Função auxiliar para Checklist no Excel
        const adicionarChecklistExcel = (tituloSecao, checklistObj, obs, imagens) => {
            if(tituloSecao) adicionarLinhaSecao(tituloSecao); // Só adiciona título se fornecido
             if (checklistObj && typeof checklistObj === 'object' && Object.keys(checklistObj).length > 0) {
                abaDetalhes.getRange(linhaAtual, 1).setValue("Checklist:").setTextStyle(boldStyle);
                linhaAtual++;
                for (const item in checklistObj) {
                    abaDetalhes.getRange(linhaAtual, 1).setValue("  " + item + ":"); // Indentação
                    abaDetalhes.getRange(linhaAtual, 2).setValue(checklistObj[item]);
                    linhaAtual++;
                }
            } else {
                 adicionarLinhaInfo("Checklist:", "(Nenhum item registrado)", null);
            }
            adicionarLinhaInfo("Observações:", obs || '(Nenhuma)', null);
            abaDetalhes.getRange(linhaAtual - 1, 2).setWrap(true);

             // Adicionar links das imagens
             if (Array.isArray(imagens) && imagens.length > 0) {
                 adicionarLinhaInfo("Imagens:", `(${imagens.length} anexos)`);
                 imagens.forEach((img, idx) => {
                     if (img && img.id && img.url) {
                         // Cria um link clicável
                         const link = SpreadsheetApp.newRichTextValue()
                             .setText(`Ver Imagem ${idx + 1} (ID: ${img.id})`)
                             .setLinkUrl(img.url)
                             .build();
                         abaDetalhes.getRange(linhaAtual, 2).setRichTextValue(link);
                         linhaAtual++;
                     } else {
                          abaDetalhes.getRange(linhaAtual, 2).setValue(`[Imagem ${idx+1} inválida]`);
                          linhaAtual++;
                     }
                 });
             } else {
                 adicionarLinhaInfo("Imagens:", "(Nenhuma)", null);
             }

            linhaAtual++; // Espaço após a seção
        };


        // Pré-Manutenção
        adicionarChecklistExcel(
            "Pré-Manutenção",
            manutencao.Checklist_Pre,
            manutencao.Observacoes_Pre,
            manutencao.Imagens_Pre
        );


        // Pós-Manutenção
        if (manutencao.Status === STATUS_CONCLUIDO || manutencao.Status === STATUS_DISPONIVEL || manutencao.Data_Manutencao) {
             adicionarLinhaSecao("Pós-Manutenção");
             adicionarLinhaInfo("Data Conclusão:", formatarData(manutencao.Data_Manutencao));
             linhaAtual--; // Volta uma linha para continuar a seção
             adicionarChecklistExcel(
                "", // Sem título de seção duplicado
                manutencao.Checklist_Pos,
                manutencao.Observacoes_Pos,
                manutencao.Imagens_Pos
            );
        }

        // Ajustar colunas
        try { abaDetalhes.autoResizeColumns(1, 1); } catch(e) {Logger.log("Resize col 1 falhou: " + e)} // Ajusta coluna de chaves
        abaDetalhes.setColumnWidth(2, 400); // Define largura maior para valores

        // --- Aba Histórico ---
        if (historico && historico.length > 0) {
          const abaHist = ssTemp.insertSheet("Histórico"); // Cria nova aba
          const cabecalhoHist = ["Data", "Status Anterior", "Status Novo", "Responsável", "Observação"];
          // Escreve cabeçalho e aplica estilo
          abaHist.getRange(1, 1, 1, cabecalhoHist.length).setValues([cabecalhoHist]).setTextStyle(boldStyle).setBackground(headerBg);
          abaHist.setFrozenRows(1);

          let linhaHist = 2;
          historico.forEach(item => {
            abaHist.getRange(linhaHist, 1).setValue(formatarData(item.Data)).setNumberFormat('dd/mm/yyyy hh:mm');
            abaHist.getRange(linhaHist, 2).setValue(item.Status_Anterior || '-');
            abaHist.getRange(linhaHist, 3).setValue(item.Status_Novo);
            abaHist.getRange(linhaHist, 4).setValue(item.Responsavel || '-');
            abaHist.getRange(linhaHist, 5).setValue(item.Observacao || '-').setWrap(true);
            linhaHist++;
          });
          try { abaHist.autoResizeColumns(1, cabecalhoHist.length); } catch (e) {Logger.log("Resize Histórico falhou: " + e)}
          abaHist.setColumnWidth(5, 350); // Largura para observação
        }

        // --- Exportação e Limpeza ---
        SpreadsheetApp.flush(); // Garante que as alterações foram salvas na planilha temporária

        // Monta a URL de exportação para .xlsx
        const urlExport = `https://docs.google.com/spreadsheets/d/${fileIdTemp}/export?format=xlsx`;
        const token = ScriptApp.getOAuthToken(); // Necessário para autenticar a requisição de exportação
        const options = {
          headers: { 'Authorization': `Bearer ${token}` },
          muteHttpExceptions: true // Para capturar erros de fetch
        };

        const response = UrlFetchApp.fetch(urlExport, options);

        if (response.getResponseCode() !== 200) {
            // Tenta ler a mensagem de erro da resposta
            let errorDetails = response.getContentText();
             try {
                 // Se for JSON, tenta formatar
                 errorDetails = JSON.stringify(JSON.parse(errorDetails), null, 2);
             } catch(parseErr) { /* ignora se não for JSON */ }
            throw new Error(`Falha ao exportar planilha temporária para Excel. Código: ${response.getResponseCode()}. Resposta: ${errorDetails}`);
        }

        const blobExcel = response.getBlob().setName(nomeArquivo);

        // Salva o arquivo Excel final na pasta de destino
        const fileExcel = folder.createFile(blobExcel);
        fileExcel.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); // Compartilha

        Logger.log(`Relatório Excel gerado: ${fileExcel.getName()} (ID: ${fileExcel.getId()})`);

        return {
          success: true,
          url: fileExcel.getUrl(),
          fileId: fileExcel.getId(),
          message: "Relatório Excel gerado com sucesso."
        };

    } catch (error) {
        Logger.log(`Erro CRÍTICO em gerarRelatorioExcel para ID ${manutencao ? manutencao.ID : 'N/A'}: ${error.message}\n${error.stack}`);
        return { success: false, message: "Erro interno ao gerar relatório Excel: " + error.message };
    } finally {
         // Garante a limpeza do arquivo temporário
        if (fileIdTemp) {
            try { DriveApp.getFileById(fileIdTemp).setTrashed(true); } catch (e) {
                 Logger.log(`Falha ao excluir arquivo temporário do Excel (${fileIdTemp}): ${e}`);
            }
        }
    }
}


/**
 * Gera um relatório em formato CSV.
 * @param {object} manutencao Objeto com os dados da manutenção.
 * @param {Array<object>} historico Array com os itens do histórico.
 * @param {object} [opcoes={}] Opções (não utilizado no momento).
 * @returns {object} { success, message, url?, fileId? }
 */
function gerarRelatorioCSV(manutencao, historico = [], opcoes = {}) {
  try {
    const folder = DriveApp.getFolderById(PASTA_IMAGENS_ID); // Pasta de destino
    const nomeArquivo = `Relatorio_${manutencao.ID}_${Utilities.formatDate(new Date(),Session.getScriptTimeZone(),"yyyyMMdd_HHmm")}.csv`;

    // Função para escapar valores para CSV (coloca entre aspas e duplica aspas internas)
    const escapeCSV = (str) => {
        const value = String(str == null ? '' : str); // Converte para string, tratando null/undefined
        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
            return `"${value.replace(/"/g, '""')}"`; // Coloca entre aspas e escapa aspas internas
        }
        return value; // Retorna o valor como está se não precisar de escape
    };

    let linhasCSV = []; // Array para guardar as linhas do CSV

    // --- Cabeçalho e Dados da Manutenção ---
    // Define as colunas que queremos no CSV principal
    const cabecalhoManut = [
        "ID", "Data_Criacao", "Status", "Placa", "Modelo", "Tipo_Equipamento",
        "Categoria_Problema", "Urgencia", "Descricao_Problema", "Motivo_Outro",
        "Observacoes_Pre", "Data_Manutencao", "Observacoes_Pos", "Responsavel",
        "Checklist_Pre_JSON", "Checklist_Pos_JSON", // Incluir checklists como JSON
        "Imagens_Pre_JSON", "Imagens_Pos_JSON" // Incluir imagens como JSON
    ];
    linhasCSV.push(cabecalhoManut.map(escapeCSV).join(',')); // Linha de cabeçalho

    // Prepara a linha de dados da manutenção
    const linhaManut = cabecalhoManut.map(header => {
      let valor = manutencao[header];
      // Tratamento especial para datas e JSON
      if (header.startsWith('Data_') && valor) {
          valor = formatarData(valor); // Usa a função de formatação padrão
      } else if (header.endsWith('_JSON')) {
           // Pega o nome original sem _JSON
           const originalHeader = header.replace('_JSON', '');
           const originalValue = manutencao[originalHeader];
           try {
               // Garante que o valor original é objeto/array antes de serializar
               let valueToSerialize = originalValue;
               if(originalHeader.startsWith('Imagens') && !Array.isArray(valueToSerialize)) valueToSerialize = [];
               else if (originalHeader.startsWith('Checklist') && (typeof valueToSerialize !== 'object' || valueToSerialize === null || Array.isArray(valueToSerialize))) valueToSerialize = {};

               valor = JSON.stringify(valueToSerialize);
           } catch (e) {
               Logger.log(`Erro ao serializar ${originalHeader} para CSV: ${e}`);
               valor = "Erro JSON";
           }
      } else if (valor === undefined || valor === null) {
          valor = '';
      }
      return escapeCSV(valor);
    });
    linhasCSV.push(linhaManut.join(','));

    // --- Histórico ---
    if (historico && historico.length > 0) {
        linhasCSV.push(''); // Linha em branco como separador
        linhasCSV.push(escapeCSV("HISTÓRICO DE ALTERAÇÕES")); // Título para a seção de histórico

        const cabecalhoHist = ["Data", "Status_Anterior", "Status_Novo", "Responsavel", "Observacao"];
        linhasCSV.push(cabecalhoHist.map(escapeCSV).join(',')); // Cabeçalho do histórico

        historico.forEach(item => {
            const linhaHist = cabecalhoHist.map(header => {
                let valor = item[header];
                if (header === 'Data' && valor) {
                    valor = formatarData(valor);
                } else if (valor === undefined || valor === null) {
                   valor = '';
                }
                 // Trata status e responsável nulos/vazios
                 if ((header === 'Status_Anterior' || header === 'Responsavel' || header === 'Observacao') && !valor) {
                     valor = '-';
                 }
                return escapeCSV(valor);
            });
            linhasCSV.push(linhaHist.join(','));
        });
    } else {
        linhasCSV.push('');
        linhasCSV.push(escapeCSV("Nenhum histórico registrado."));
    }

    // --- Criação do Arquivo ---
    const csvContent = linhasCSV.join('\n'); // Junta as linhas com quebra de linha
    // Usar UTF-8 para melhor compatibilidade
    const blobCSV = Utilities.newBlob(csvContent, MimeType.CSV, nomeArquivo).setDataFromString(csvContent, 'UTF-8');
    const fileCSV = folder.createFile(blobCSV);
    fileCSV.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); // Compartilha

    Logger.log(`Relatório CSV gerado: ${fileCSV.getName()} (ID: ${fileCSV.getId()})`);

    return {
      success: true,
      url: fileCSV.getUrl(),
      fileId: fileCSV.getId(),
      message: "Relatório CSV gerado com sucesso."
    };

  } catch (error) {
    Logger.log(`Erro CRÍTICO em gerarRelatorioCSV para ID ${manutencao ? manutencao.ID : 'N/A'}: ${error.message}\n${error.stack}`);
    return { success: false, message: "Erro interno ao gerar relatório CSV: " + error.message };
  }
}


// ========================================================================
// Funções de Notificação por E-mail
// ========================================================================

/**
 * Envia e-mail de notificação sobre uma manutenção.
 * @param {string} idManutencao ID da manutenção.
 * @param {Array<string>} [destinatarios=[]] Lista de e-mails para enviar. Se vazio, busca na configuração.
 * @param {string} [tipo='atualizacao'] Tipo de notificação ('nova', 'atualizacao', 'conclusao', 'alerta').
 * @returns {object} { success: boolean, message: string }
 */
function enviarEmailNotificacao(idManutencao, destinatarios = [], tipo = 'atualizacao') {
  try {
    if (!idManutencao) throw new Error("ID da manutenção não fornecido para notificação.");

    // 1. Obtém os dados da manutenção
    const resManut = obterManutencao(idManutencao);
    if (!resManut.success || !resManut.manutencao) {
      Logger.log(`Email não enviado (tipo ${tipo}): Manutenção ${idManutencao} não encontrada.`);
      // Retorna sucesso parcial, pois a falha não é no envio em si, mas na busca dos dados.
      return { success: false, message: `Manutenção ${idManutencao} não encontrada para enviar notificação.` };
    }
    const manut = resManut.manutencao;

    // 2. Determina os destinatários
    let emailsParaEnviar = [];
    if (Array.isArray(destinatarios) && destinatarios.length > 0) {
       // Filtra para garantir que são e-mails válidos (simplificado)
       emailsParaEnviar = destinatarios.filter(e => typeof e === 'string' && e.includes('@'));
       // Logger.log(`Usando destinatários fornecidos para notificação ${idManutencao} (${tipo}): ${emailsParaEnviar.join(', ')}`);
    } else {
       emailsParaEnviar = obterDestinatariosNotificacao(); // Busca na aba Configurações
       // Logger.log(`Buscando destinatários na configuração para notificação ${idManutencao} (${tipo}). Encontrados: ${emailsParaEnviar.join(', ')}`);
    }

    // Se não houver destinatários válidos, não envia.
    if (emailsParaEnviar.length === 0) {
      Logger.log(`Nenhum destinatário válido encontrado para notificação ${idManutencao} (${tipo}). E-mail não enviado.`);
      return { success: true, message: "Nenhum destinatário configurado ou fornecido para enviar e-mail." };
    }

    // 3. Define Assunto e Corpo do E-mail com base no tipo
    let assunto, corpoHtml;
    const urlBaseApp = ScriptApp.getService().getUrl(); // URL do Web App
    // Adiciona um parâmetro para visualização direta no frontend (se o frontend suportar)
    const urlVerDetalhes = `${urlBaseApp}?action=view&id=${manutencao.ID}`;

    switch (tipo) {
      case 'nova':
        assunto = `[Manutenção GPS] Nova Solicitação: ${manut.Placa || 'S/Placa'} (${manut.ID})`;
        corpoHtml = construirEmailNovaSolicitacao(manut, urlVerDetalhes);
        break;
      case 'atualizacao':
        assunto = `[Manutenção GPS] Status Atualizado: ${manut.Status} - ${manut.Placa || 'S/Placa'} (${manut.ID})`;
        corpoHtml = construirEmailAtualizacao(manut, urlVerDetalhes);
        break;
      case 'conclusao':
        assunto = `[Manutenção GPS] Concluída: ${manut.Placa || 'S/Placa'} (${manut.ID})`;
        corpoHtml = construirEmailConclusao(manut, urlVerDetalhes);
        break;
      case 'alerta':
        assunto = `[ALERTA URGENTE - Manutenção GPS] Solicitação Urgente: ${manut.Placa || 'S/Placa'} (${manut.ID})`;
        corpoHtml = construirEmailAlerta(manut, urlVerDetalhes);
        break;
      default: // Caso genérico ou tipo desconhecido
        assunto = `[Manutenção GPS] Notificação: ${manut.Placa || 'S/Placa'} (${manut.ID})`;
        corpoHtml = construirEmailGenerico(manut, urlVerDetalhes);
        tipo = 'generica'; // Normaliza o tipo para o log
    }

    // 4. Verifica se o e-mail pode ser enviado (Cotas do Google Apps Script)
    const cotaRestante = MailApp.getRemainingDailyQuota();
    if (cotaRestante < emailsParaEnviar.length) { // Verifica se a cota cobre todos os destinatários
        Logger.log(`AVISO: Cota de e-mail (${cotaRestante}) insuficiente para enviar para ${emailsParaEnviar.length} destinatários. E-mail ${idManutencao} (${tipo}) não enviado.`);
        // Pode tentar enviar para um admin ou apenas logar
        // MailApp.sendEmail(ADMIN_EMAIL, "Alerta de Cota de E-mail Baixa", `A cota de e-mail está baixa (${cotaRestante}) e não foi possível enviar a notificação ${idManutencao} (${tipo}).`);
        return { success: false, message: `Cota de e-mail diária (${cotaRestante}) insuficiente.` };
    }


    // 5. Envia o E-mail
    MailApp.sendEmail({
      to: emailsParaEnviar.join(','), // Junta os e-mails com vírgula
      subject: assunto,
      htmlBody: corpoHtml,
      // Opcional: Adicionar um remetente "no-reply" se configurado no projeto
      // noReply: true,
      // Opcional: Adicionar CC ou CCO
      // cc: 'gerente@dominio.com',
      // bcc: 'arquivo@dominio.com'
    });

    Logger.log(`E-mail de notificação (tipo: ${tipo}) enviado com sucesso para ${emailsParaEnviar.join(', ')} referente à manutenção ${idManutencao}. Cota restante: ${MailApp.getRemainingDailyQuota()}`);

    // 6. Registra o envio no histórico da manutenção
    registrarHistorico(manut.ID, manut.Placa, manut.Status, manut.Status, "Sistema", `Notificação por e-mail (tipo: ${tipo}) enviada para ${emailsParaEnviar.length} destinatário(s).`);

    return {
      success: true,
      message: `E-mail de notificação (tipo: ${tipo}) enviado para ${emailsParaEnviar.length} destinatário(s).`
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO ao enviar e-mail de notificação para ID ${idManutencao} (tipo ${tipo}): ${e.message}\n${e.stack}`);
    // Tenta registrar o erro no histórico
     try { registrarHistorico(idManutencao || 'N/A', 'N/A', 'Erro', 'Erro', 'Sistema', `Falha ao enviar e-mail (${tipo}): ${e.message}`); } catch(histErr){}
    return { success: false, message: "Erro ao enviar e-mail de notificação: " + e.message };
  }
}


/**
 * Obtém a lista de e-mails da configuração 'EMAILS_NOTIFICACAO'.
 * @returns {Array<string>} Lista de e-mails válidos.
 */
function obterDestinatariosNotificacao() {
  try {
    const configResult = obterConfiguracoes(); // Usa a função que lê todas as configs
    if (configResult.success && configResult.configuracoes) {
      const emailsString = configResult.configuracoes['EMAILS_NOTIFICACAO']; // Chave exata da aba Configurações

      if (emailsString && typeof emailsString === 'string') {
        // Divide a string por vírgula ou ponto e vírgula, remove espaços e filtra inválidos
        const emailsArray = emailsString.split(/[,;]+/) // Divide por , ou ;
                                        .map(email => email.trim()) // Remove espaços extras
                                        .filter(email => email && email.includes('@')); // Filtra válidos (contém @)
        return emailsArray;
      }
    }
    // Se não encontrou a chave ou deu erro ao ler configs, retorna vazio
    // Logger.log("Chave 'EMAILS_NOTIFICACAO' não encontrada ou vazia nas configurações.");
    return [];
  } catch (e) {
    Logger.log("Erro ao obter destinatários da configuração: " + e);
    return []; // Retorna array vazio em caso de erro
  }
}


// --- Funções para construir o corpo HTML dos e-mails ---

function construirEmailBase(titulo, manut, urlVerDetalhes, conteudoEspecifico) {
    // Estilos CSS básicos inline para melhor compatibilidade entre clientes de e-mail
    const styles = {
        body: 'font-family: Arial, sans-serif; font-size: 10pt; line-height: 1.5; color: #333;',
        container: 'border: 1px solid #ccc; padding: 20px; max-width: 600px; margin: 10px;',
        h2: 'color: #0056b3; font-size: 14pt; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px;',
        p: 'margin-bottom: 10px;',
        strong: 'font-weight: bold;',
        aButton: 'display: inline-block; padding: 8px 15px; background-color: #007bff; color: #ffffff; text-decoration: none; border-radius: 4px; font-size: 10pt;',
        footer: 'font-size: 9pt; color: #888; margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px;'
    };

    // Status com cores (exemplo)
    const statusStyle = getStatusStyleEmail(manut.Status);

    return `<html>
<head><meta charset="utf-8"></head>
<body style="${styles.body}">
  <div style="${styles.container}">
    <h2 style="${styles.h2}">${titulo} (#${manut.ID})</h2>
    <p style="${styles.p}">
      <strong style="${styles.strong}">Equipamento:</strong> ${manut.Placa || 'N/A'} (${manut.Tipo_Equipamento || 'N/A'})<br>
      <strong style="${styles.strong}">Status Atual:</strong> <span style="${statusStyle}">${manut.Status || 'N/A'}</span>
    </p>
    ${conteudoEspecifico}
    <p style="${styles.p}">
      <a href="${urlVerDetalhes}" style="${styles.aButton}" target="_blank">Ver Detalhes no Sistema</a>
    </p>
    <div style="${styles.footer}">
      Sistema de Manutenção GPS | Gerado em: ${formatarData(new Date())}
    </div>
  </div>
</body></html>`;
}


function construirEmailNovaSolicitacao(m, url) {
  const conteudo = `
    <p style="margin-bottom: 10px;">Uma nova solicitação de manutenção foi registrada:</p>
    <p style="margin-bottom: 5px;"><strong style="font-weight: bold;">Problema:</strong> ${m.Categoria_Problema || 'N/A'}</p>
    <p style="margin-bottom: 5px;"><strong style="font-weight: bold;">Urgência:</strong> ${m.Urgencia || 'N/A'}</p>
    <p style="margin-bottom: 10px;"><strong style="font-weight: bold;">Descrição:</strong> ${m.Descricao_Problema || 'N/A'}</p>
    ${m.Motivo_Outro ? `<p style="margin-bottom: 10px;"><strong style="font-weight: bold;">Detalhe (Outro):</strong> ${m.Motivo_Outro}</p>` : ''}
  `;
  return construirEmailBase("Nova Solicitação de Manutenção", m, url, conteudo);
}

function construirEmailAtualizacao(m, url) {
  const conteudo = `
    <p style="margin-bottom: 10px;">O status da manutenção foi atualizado.</p>
    <p style="margin-bottom: 10px;"><strong style="font-weight: bold;">Responsável pela atualização:</strong> ${m.Responsavel || 'Sistema'}</p>
    `;
    // Opcional: adicionar histórico recente?
  return construirEmailBase("Atualização de Status", m, url, conteudo);
}

function construirEmailConclusao(m, url) {
  const conteudo = `
    <p style="margin-bottom: 10px;">A manutenção foi marcada como concluída ou o equipamento como disponível.</p>
    <p style="margin-bottom: 5px;"><strong style="font-weight: bold;">Data de Conclusão (ou última atualização):</strong> ${formatarData(m.Data_Manutencao || m.Data_Atualizacao)}</p>
    <p style="margin-bottom: 10px;"><strong style="font-weight: bold;">Observações Pós-Manutenção:</strong> ${m.Observacoes_Pos || '(Nenhuma)'}</p>
    `;
  return construirEmailBase("Manutenção Concluída / Equipamento Disponível", m, url, conteudo);
}

function construirEmailAlerta(m, url) {
  const conteudo = `
    <p style="margin-bottom: 10px; color: red; font-weight: bold;">ATENÇÃO! Esta é uma solicitação de manutenção URGENTE!</p>
    <p style="margin-bottom: 5px;"><strong style="font-weight: bold;">Problema:</strong> ${m.Categoria_Problema || 'N/A'}</p>
    <p style="margin-bottom: 5px;"><strong style="font-weight: bold;">Urgência:</strong> <span style="color: red; font-weight: bold;">${m.Urgencia || 'N/A'}</span></p>
    <p style="margin-bottom: 10px;"><strong style="font-weight: bold;">Descrição:</strong> ${m.Descricao_Problema || 'N/A'}</p>
  `;
  // Modifica o container para ter borda vermelha
   const styles = {
        body: 'font-family: Arial, sans-serif; font-size: 10pt; line-height: 1.5; color: #333;',
        container: 'border: 3px solid red; padding: 20px; max-width: 600px; margin: 10px;', // Borda Vermelha
        h2: 'color: #cc0000; font-size: 14pt; margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid #fcc; padding-bottom: 5px;',
        p: 'margin-bottom: 10px;',
        strong: 'font-weight: bold;',
        aButton: 'display: inline-block; padding: 8px 15px; background-color: #dc3545; color: #ffffff; text-decoration: none; border-radius: 4px; font-size: 10pt;', // Botão Vermelho
        footer: 'font-size: 9pt; color: #888; margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px;'
    };
     const statusStyle = getStatusStyleEmail(m.Status);

     return `<html>
        <head><meta charset="utf-8"></head>
        <body style="${styles.body}">
          <div style="${styles.container}">
            <h2 style="${styles.h2}">ALERTA URGENTE - Manutenção #${m.ID}</h2>
            <p style="${styles.p}">
              <strong style="${styles.strong}">Equipamento:</strong> ${m.Placa || 'N/A'} (${m.Tipo_Equipamento || 'N/A'})<br>
              <strong style="${styles.strong}">Status Atual:</strong> <span style="${statusStyle}">${m.Status || 'N/A'}</span>
            </p>
            ${conteudo}
            <p style="${styles.p}">
              <a href="${url}" style="${styles.aButton}" target="_blank">Ver Detalhes URGENTE</a>
            </p>
            <div style="${styles.footer}">
              Sistema de Manutenção GPS | Gerado em: ${formatarData(new Date())}
            </div>
          </div>
        </body></html>`;
}

function construirEmailGenerico(m, url) {
  const conteudo = `<p style="margin-bottom: 10px;">Notificação referente à manutenção.</p>`;
  return construirEmailBase("Notificação de Manutenção", m, url, conteudo);
}

/** Retorna estilo CSS inline para o status */
function getStatusStyleEmail(status) {
  let style = 'padding: 2px 5px; border-radius: 3px; color: #fff; font-weight: bold; font-size: 9pt; white-space: nowrap;';
  switch (status) {
    case STATUS_AGUARDANDO: return style + ' background-color: #ffc107; color: #333;'; // Amarelo
    case STATUS_EM_MANUTENCAO: return style + ' background-color: #007bff;'; // Azul
    case STATUS_CONCLUIDO: return style + ' background-color: #28a745;'; // Verde
    case STATUS_DISPONIVEL: return style + ' background-color: #17a2b8;'; // Ciano/Azul claro
    default: return 'font-weight: bold;'; // Sem fundo se desconhecido
  }
}


// ========================================================================
// Funções de Integração e Agendamento
// ========================================================================

/**
 * Atualiza uma planilha de controle de turnos com equipamentos indisponíveis.
 * @param {string|null} [idPlanilhaTurnosParam=null] ID da planilha de turnos. Se null, busca na config.
 * @returns {object} { success: boolean, message: string, equipamentosIndisponiveis?: Array<string> }
 */
function integrarComPlanilhaTurnos(idPlanilhaTurnosParam = null) {
  let pTurnos; // Variável para a planilha de turnos
  try {
    // 1. Determina o ID da Planilha de Turnos
    let idPlanilhaTurnos = idPlanilhaTurnosParam;
    if (!idPlanilhaTurnos) {
      const cfg = obterConfiguracoes();
      idPlanilhaTurnos = cfg.success ? cfg.configuracoes['ID_PLANILHA_TURNOS'] : null;
      if (!idPlanilhaTurnos || typeof idPlanilhaTurnos !== 'string' || idPlanilhaTurnos.trim() === '') {
        Logger.log("Integração não realizada: ID da Planilha de Turnos não fornecido ou não configurado na aba 'Configurações'.");
        return { success: false, message: "ID da Planilha de Turnos não configurado." };
      }
       // Logger.log(`ID da Planilha de Turnos obtido da configuração: ${idPlanilhaTurnos}`);
    } else {
         // Logger.log(`ID da Planilha de Turnos fornecido via parâmetro: ${idPlanilhaTurnosParam}`);
    }


    // 2. Abre a Planilha de Turnos
    try {
      pTurnos = SpreadsheetApp.openById(idPlanilhaTurnos);
       // Logger.log(`Planilha de Turnos '${pTurnos.getName()}' aberta com sucesso.`);
    } catch (e) {
      Logger.log(`Erro ao abrir planilha de turnos com ID ${idPlanilhaTurnos}: ${e.message}`);
      return { success: false, message: `Erro ao acessar a planilha de turnos (ID: ${idPlanilhaTurnos}). Verifique o ID e as permissões. Detalhe: ${e.message}` };
    }

    // 3. Acessa a Aba 'Turnos' (ou nome configurável?)
    let nomeAbaTurnos = 'Turnos'; // Assumindo nome fixo
    let abaTurnos = pTurnos.getSheetByName(nomeAbaTurnos);
    if (!abaTurnos) {
        Logger.log(`Aba '${nomeAbaTurnos}' não encontrada na planilha de turnos '${pTurnos.getName()}'.`);
        return { success: false, message: `Aba '${nomeAbaTurnos}' não encontrada na planilha de turnos.` };
    }
     // Logger.log(`Aba '${nomeAbaTurnos}' encontrada.`);

    // 4. Obtém a lista de equipamentos indisponíveis da Planilha de Manutenção
    const resEquipamentos = obterEquipamentos(); // Usa a função existente
    if (!resEquipamentos.success) {
        return { success: false, message: `Falha ao obter lista de equipamentos: ${resEquipamentos.message}` };
    }
    const equipamentosIndisponiveis = resEquipamentos.equipamentos
      .filter(eq => eq.Status === 'Em Manutenção' || eq.Status === 'Aguardando Manutenção')
      .map(eq => `${eq.Placa || 'S/Placa'} (${eq.Modelo || 'S/Modelo'}) - ${eq.Status}`); // Formato: PLACA (MODELO) - STATUS

    Logger.log(`Equipamentos indisponíveis encontrados: ${equipamentosIndisponiveis.length}`);


    // 5. Encontra ou cria a coluna para equipamentos indisponíveis na aba Turnos
    const dadosTurnos = abaTurnos.getDataRange().getValues();
    const cabecalhosTurnos = dadosTurnos.length > 0 ? dadosTurnos[0].map(h => String(h).trim()) : [];
    let nomeColunaIndisponiveis = 'Equipamentos Indisponíveis'; // Nome padrão da coluna
    let colIdxIndisponiveis = cabecalhosTurnos.findIndex(h => h.toUpperCase() === nomeColunaIndisponiveis.toUpperCase());

    if (colIdxIndisponiveis === -1) {
      // Tenta nomes alternativos comuns
      const nomesAlternativos = ['Equipamentos em Manutenção', 'Indisponíveis', 'Manutenção'];
      for (const nomeAlt of nomesAlternativos) {
           colIdxIndisponiveis = cabecalhosTurnos.findIndex(h => h.toUpperCase() === nomeAlt.toUpperCase());
           if (colIdxIndisponiveis !== -1) {
               nomeColunaIndisponiveis = cabecalhosTurnos[colIdxIndisponiveis]; // Usa o nome encontrado
               Logger.log(`Coluna de indisponíveis encontrada com nome alternativo: '${nomeColunaIndisponiveis}' (Índice ${colIdxIndisponiveis})`);
               break;
           }
      }
    }

    if (colIdxIndisponiveis === -1) {
      // Se ainda não encontrou, cria a coluna no final
      colIdxIndisponiveis = cabecalhosTurnos.length; // Próxima coluna vazia
      abaTurnos.getRange(1, colIdxIndisponiveis + 1).setValue(nomeColunaIndisponiveis).setFontWeight('bold');
      Logger.log(`Coluna '${nomeColunaIndisponiveis}' criada na aba '${nomeAbaTurnos}' (Índice ${colIdxIndisponiveis}).`);
      SpreadsheetApp.flush(); // Garante que a coluna seja criada antes de continuar
    } else {
        // Logger.log(`Coluna '${nomeColunaIndisponiveis}' encontrada na aba '${nomeAbaTurnos}' (Índice ${colIdxIndisponiveis}).`);
    }


    // 6. Encontra a linha correspondente à data de HOJE na aba Turnos
    // Assume que a data está na primeira coluna (A)
    const colunaDataIdx = 0; // Índice 0 para coluna A
    const hojeFormatado = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'dd/MM/yyyy');
    let linhaHoje = -1;

    for (let i = 1; i < dadosTurnos.length; i++) { // Começa da linha 2 (índice 1)
      const valorCelulaData = dadosTurnos[i][colunaDataIdx];
      let dataCelulaFormatada = '';

      if (valorCelulaData instanceof Date && !isNaN(valorCelulaData.getTime())) {
        dataCelulaFormatada = Utilities.formatDate(valorCelulaData, Session.getScriptTimeZone(), 'dd/MM/yyyy');
      } else if (typeof valorCelulaData === 'string' || typeof valorCelulaData === 'number') {
        // Tenta formatar como string se for texto ou número parecido com data
        try { dataCelulaFormatada = Utilities.formatDate(new Date(valorCelulaData), Session.getScriptTimeZone(), 'dd/MM/yyyy'); } catch(e){}
        if (!dataCelulaFormatada) dataCelulaFormatada = String(valorCelulaData).trim(); // Usa como texto se falhar
      }

      if (dataCelulaFormatada === hojeFormatado) {
        linhaHoje = i + 1; // Número da linha (base 1)
        // Logger.log(`Linha correspondente à data de hoje (${hojeFormatado}) encontrada: ${linhaHoje}`);
        break;
      }
    }

    // Se não encontrou a linha de hoje, adiciona uma nova linha
    if (linhaHoje === -1) {
      linhaHoje = abaTurnos.getLastRow() + 1;
      abaTurnos.getRange(linhaHoje, colunaDataIdx + 1).setValue(new Date()).setNumberFormat('dd/MM/yyyy');
      Logger.log(`Linha para a data de hoje (${hojeFormatado}) não encontrada. Adicionando na linha ${linhaHoje}.`);
       SpreadsheetApp.flush(); // Garante criação da linha
    }

    // 7. Escreve a lista de equipamentos indisponíveis na célula correta
    const textoEquipamentos = equipamentosIndisponiveis.join('\n') || '-'; // Usa hífen se não houver nenhum
    const celulaDestino = abaTurnos.getRange(linhaHoje, colIdxIndisponiveis + 1);
    // Só escreve se o conteúdo for diferente para otimizar
    if (celulaDestino.getValue() !== textoEquipamentos) {
        celulaDestino.setValue(textoEquipamentos).setWrapStrategy(SpreadsheetApp.WrapStrategy.WRAP); // Habilita quebra de linha
        Logger.log(`Lista de equipamentos indisponíveis atualizada na célula ${celulaDestino.getA1Notation()}.`);
    } else {
        // Logger.log(`Lista de equipamentos indisponíveis na célula ${celulaDestino.getA1Notation()} já está atualizada.`);
    }


    // 8. Retorna sucesso
    return {
      success: true,
      message: `Planilha de turnos atualizada com ${equipamentosIndisponiveis.length} equipamento(s) indisponível(is).`,
      equipamentosIndisponiveis: equipamentosIndisponiveis
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO durante a integração com a planilha de turnos: ${e.message}\n${e.stack}`);
    // Tenta identificar se o erro foi ao abrir a planilha
    let msgErro = "Erro durante a integração com a planilha de turnos: " + e.message;
    if (e.message.includes("openById") && pTurnos === undefined) {
        msgErro = `Erro ao abrir a planilha de turnos (ID: ${idPlanilhaTurnosParam || 'Configurado'}). Verifique o ID e permissões. Detalhe: ${e.message}`;
    }
    return { success: false, message: msgErro };
  }
}


/**
 * Configura ou reconfigura os gatilhos (triggers) baseados em tempo.
 * Remove gatilhos antigos para evitar duplicação e cria os novos conforme configuração.
 * @returns {object} { success: boolean, message: string, integracaoAutomatica?: boolean }
 */
function configurarGatilhoAutomatico() {
  try {
    const nomeFuncaoIntegracao = 'executarIntegracaoAutomatica';
    const nomeFuncaoUrgencia = 'verificarManutencoesUrgentes';
    let triggersExcluidos = { integracao: 0, urgencia: 0 };
    let mensagens = [];

    // 1. Remove gatilhos existentes para estas funções para evitar duplicação
    const triggersAtuais = ScriptApp.getProjectTriggers();
    triggersAtuais.forEach(trigger => {
      const handlerFunction = trigger.getHandlerFunction();
      if (handlerFunction === nomeFuncaoIntegracao) {
        ScriptApp.deleteTrigger(trigger);
        triggersExcluidos.integracao++;
        Logger.log(`Gatilho de integração existente removido (ID: ${trigger.getUniqueId()}).`);
      } else if (handlerFunction === nomeFuncaoUrgencia) {
        ScriptApp.deleteTrigger(trigger);
        triggersExcluidos.urgencia++;
         Logger.log(`Gatilho de urgência existente removido (ID: ${trigger.getUniqueId()}).`);
      }
    });
    if (triggersExcluidos.integracao > 0) mensagens.push(`Removido(s) ${triggersExcluidos.integracao} gatilho(s) de integração existente(s).`);
    if (triggersExcluidos.urgencia > 0) mensagens.push(`Removido(s) ${triggersExcluidos.urgencia} gatilho(s) de urgência existente(s).`);

    // 2. Verifica a configuração de integração automática
    const cfg = obterConfiguracoes();
    let integracaoAtiva = false;
    if (cfg.success && cfg.configuracoes) {
        const valorConfig = String(cfg.configuracoes['INTEGRACAO_AUTOMATICA']).toUpperCase();
        integracaoAtiva = (valorConfig === 'SIM' || valorConfig === 'TRUE' || valorConfig === '1');
         Logger.log(`Configuração INTEGRAÇÃO_AUTOMATICA: ${cfg.configuracoes['INTEGRACAO_AUTOMATICA']} -> Ativa? ${integracaoAtiva}`);
    } else {
        Logger.log("AVISO: Não foi possível ler a configuração 'INTEGRAÇÃO_AUTOMATICA'. Assumindo como desativada.");
    }

    // 3. Cria o gatilho de integração se estiver ativo
    if (integracaoAtiva) {
      try {
          ScriptApp.newTrigger(nomeFuncaoIntegracao)
            .timeBased()
            .everyDays(1) // Executa todo dia
            .atHour(6)    // Por volta das 6 da manhã (fuso horário do servidor/script)
            // .nearMinute(0) // Opcional: tentar executar próximo ao início da hora
            // .inTimezone(Session.getScriptTimeZone()) // Opcional: definir fuso explicitamente
            .create();
          mensagens.push("Gatilho de integração diária (aprox. 6h) ATIVADO.");
          Logger.log("Gatilho de integração criado.");
      } catch (e) {
           Logger.log(`Erro ao criar gatilho de integração: ${e}`);
           mensagens.push("ERRO ao criar gatilho de integração.");
           // Não define integracaoAtiva como false, pois a configuração pedia, mas falhou ao criar
      }
    } else {
      mensagens.push("Gatilho de integração diária DESATIVADO (conforme configuração).");
    }

    // 4. Cria os gatilhos para verificação de urgência (ex: 2 vezes ao dia)
    try {
        // Gatilho da manhã
        ScriptApp.newTrigger(nomeFuncaoUrgencia)
          .timeBased()
          .everyDays(1)
          .atHour(9) // Por volta das 9h
          .create();
         Logger.log("Gatilho de urgência (9h) criado.");

         // Gatilho da tarde
         ScriptApp.newTrigger(nomeFuncaoUrgencia)
          .timeBased()
          .everyDays(1)
          .atHour(15) // Por volta das 15h
          .create();
          Logger.log("Gatilho de urgência (15h) criado.");

        mensagens.push("Gatilhos de verificação de urgência (aprox. 9h e 15h) ATIVADOS.");
    } catch (e) {
         Logger.log(`Erro ao criar gatilho(s) de urgência: ${e}`);
         mensagens.push("ERRO ao criar gatilho(s) de urgência.");
    }


    return {
      success: true,
      message: mensagens.join(' '),
      integracaoAutomatica: integracaoAtiva // Retorna o status da integração baseado na config
    };

  } catch (e) {
    Logger.log(`Erro CRÍTICO em configurarGatilhoAutomatico: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao configurar gatilhos automáticos: " + e.message };
  }
}


/**
 * Função a ser chamada pelo gatilho para executar a integração com planilha de turnos.
 */
function executarIntegracaoAutomatica() {
  const startTime = new Date();
  Logger.log(`[GATILHO ${startTime.toISOString()}] Iniciando execução da integração automática...`);

  try {
    // Verifica se a integração está realmente ativa na configuração ANTES de executar
    const cfg = obterConfiguracoes();
    let integracaoAtiva = false;
     if (cfg.success && cfg.configuracoes) {
        const valorConfig = String(cfg.configuracoes['INTEGRACAO_AUTOMATICA']).toUpperCase();
        integracaoAtiva = (valorConfig === 'SIM' || valorConfig === 'TRUE' || valorConfig === '1');
    }

    if(integracaoAtiva) {
        Logger.log("Integração automática está ATIVA. Executando...");
        const resultadoIntegracao = integrarComPlanilhaTurnos(); // Chama a função principal
        Logger.log("Resultado da integração automática: " + JSON.stringify(resultadoIntegracao));
        // Opcional: Enviar e-mail para admin em caso de falha na integração
        if (!resultadoIntegracao.success) {
             // MailApp.sendEmail(ADMIN_EMAIL, "[Erro] Falha na Integração Automática de Turnos", `Ocorreu um erro durante a integração automática: ${resultadoIntegracao.message}`);
        }
    } else {
        Logger.log("Integração automática está DESATIVADA na configuração. Nenhuma ação realizada.");
    }

  } catch (e) {
    Logger.log(`ERRO FATAL durante a execução da integração automática: ${e.message}\nStack: ${e.stack}`);
     // Opcional: Enviar e-mail para admin sobre o erro fatal
     // MailApp.sendEmail(ADMIN_EMAIL, "[Erro Fatal] Falha na Integração Automática de Turnos", `Ocorreu um erro fatal durante a integração automática: ${e.message}\n${e.stack}`);
  } finally {
      const endTime = new Date();
      const duration = (endTime.getTime() - startTime.getTime()) / 1000;
      Logger.log(`[GATILHO ${endTime.toISOString()}] Execução da integração automática finalizada. Duração: ${duration} segundos.`);
  }
}


/**
 * Função a ser chamada pelo gatilho para verificar manutenções urgentes/atrasadas.
 */
function verificarManutencoesUrgentes() {
  const startTime = new Date();
  Logger.log(`[GATILHO ${startTime.toISOString()}] Iniciando verificação de manutenções urgentes/atrasadas...`);

  try {
    const plan = obterPlanilha();
    const abaM = plan.getSheetByName(NOME_PLANILHA_MANUTENCOES);

    if (!abaM) {
      Logger.log("Verificação de urgências cancelada: Aba Manutenções não encontrada.");
      return;
    }

    const dados = abaM.getDataRange().getValues();
    if (dados.length <= 1) {
        Logger.log("Nenhuma manutenção para verificar.");
        return;
    }

    const cabecalhos = dados[0].map(h=>String(h).trim());
    const idxID = cabecalhos.indexOf('ID');
    const idxStatus = cabecalhos.indexOf('Status');
    const idxUrgencia = cabecalhos.indexOf('Urgencia');
    const idxDataCriacao = cabecalhos.indexOf('Data_Criacao');

    if ([idxID, idxStatus, idxUrgencia, idxDataCriacao].includes(-1)) {
      Logger.log("Verificação de urgências cancelada: Colunas essenciais (ID, Status, Urgencia, Data_Criacao) não encontradas.");
      return;
    }

    const agora = new Date();
    const umDiaMillis = 24 * 60 * 60 * 1000;
    const tresDiasMillis = 3 * umDiaMillis;
    const LIMITE_EMAILS_POR_EXECUCAO = 10; // Para evitar exceder cota em casos extremos
    let emailsEnviados = 0;
    let alertasEnviados = 0;
    let notificacoesAtrasoEnviadas = 0;

    // Itera por todas as manutenções
    for (let i = 1; i < dados.length; i++) {
        if (emailsEnviados >= LIMITE_EMAILS_POR_EXECUCAO) {
            Logger.log(`Limite de ${LIMITE_EMAILS_POR_EXECUCAO} e-mails por execução atingido. Verificação interrompida.`);
            break;
        }

        const linha = dados[i];
        const id = String(linha[idxID]).trim();
        const status = String(linha[idxStatus]).trim();
        const urgencia = String(linha[idxUrgencia]).trim();
        let dataCriacao = null;

        // Converte a data de criação (pode ser Date ou String)
        if (linha[idxDataCriacao] instanceof Date && !isNaN(linha[idxDataCriacao].getTime())) {
            dataCriacao = linha[idxDataCriacao];
        } else {
            try {
                let dataTemp = new Date(linha[idxDataCriacao]);
                if (!isNaN(dataTemp.getTime())) dataCriacao = dataTemp;
            } catch (e) {}
        }

        // Pula se não tiver dados essenciais ou se já estiver concluída/disponível
        if (!id || !status || !dataCriacao || status === STATUS_CONCLUIDO || status === STATUS_DISPONIVEL) {
            continue;
        }

        const tempoAbertoMillis = agora.getTime() - dataCriacao.getTime();

        // Condição 1: Alerta para Alta Urgência aberta há mais de 1 dia
        if (status === STATUS_AGUARDANDO && urgencia === 'Alta' && tempoAbertoMillis > umDiaMillis) {
            Logger.log(`Manutenção ${id} (Alta Urgência) aberta há mais de 1 dia. Enviando alerta...`);
            const resEmail = enviarEmailNotificacao(id, [], 'alerta');
            if(resEmail.success) {
                alertasEnviados++;
                emailsEnviados++;
                 Utilities.sleep(1000); // Pausa entre e-mails para evitar problemas de cota/spam
            } else {
                 Logger.log(`Falha ao enviar alerta para ${id}: ${resEmail.message}`);
            }
        }
        // Condição 2: Notificação para qualquer manutenção Aguardando há mais de 3 dias
        else if (status === STATUS_AGUARDANDO && tempoAbertoMillis > tresDiasMillis) {
             Logger.log(`Manutenção ${id} (Status Aguardando) aberta há mais de 3 dias. Enviando notificação de atraso...`);
             // Usar tipo 'atualizacao' ou criar um tipo 'atraso'? Usando 'atualizacao' por ora.
             const resEmail = enviarEmailNotificacao(id, [], 'atualizacao');
             if (resEmail.success) {
                 notificacoesAtrasoEnviadas++;
                 emailsEnviados++;
                 Utilities.sleep(1000);
             } else {
                 Logger.log(`Falha ao enviar notificação de atraso para ${id}: ${resEmail.message}`);
             }
        }
         // Adicionar mais condições se necessário (ex: Em Manutenção por muito tempo)
    }

    Logger.log(`Verificação de urgências concluída. Alertas enviados: ${alertasEnviados}. Notificações de atraso enviadas: ${notificacoesAtrasoEnviadas}. Total de e-mails: ${emailsEnviados}.`);

  } catch (e) {
    Logger.log(`Erro CRÍTICO durante a verificação de urgências: ${e.message}\n${e.stack}`);
     // Opcional: Enviar e-mail para admin
     // MailApp.sendEmail(ADMIN_EMAIL, "[Erro] Falha na Verificação de Urgências", `Ocorreu um erro: ${e.message}\n${e.stack}`);
  } finally {
      const endTime = new Date();
      const duration = (endTime.getTime() - startTime.getTime()) / 1000;
      Logger.log(`[GATILHO ${endTime.toISOString()}] Verificação de urgências finalizada. Duração: ${duration} segundos.`);
  }
}


// ========================================================================
// Funções de Configuração (Leitura/Escrita)
// ========================================================================

/**
 * Obtém todas as configurações chave/valor da aba 'Configurações'.
 * Lê as colunas A (Chave) e B (Valor). Ignora linhas que fazem parte de listas verticais.
 * @returns {object} { success: boolean, configuracoes?: object, message?: string }
 */
function obterConfiguracoes() {
  try {
    const plan = obterPlanilha(); // Garante que a aba exista
    const abaCfg = plan.getSheetByName(NOME_PLANILHA_CONFIGURACOES);

    if (!abaCfg) {
        // Tenta recriar se não existir (embora obterPlanilha devesse ter feito)
        criarAbaConfiguracoes(plan);
        SpreadsheetApp.flush();
        const abaCfgNova = plan.getSheetByName(NOME_PLANILHA_CONFIGURACOES);
        if (!abaCfgNova) return { success: false, message: `Aba '${NOME_PLANILHA_CONFIGURACOES}' não encontrada e não pôde ser criada.` };
        // Se criou, chama a função novamente para ler os dados default
        return obterConfiguracoes();
    }

    // Lê as colunas A e B até a última linha com dados
    const dados = abaCfg.getRange("A1:B" + abaCfg.getLastRow()).getValues();
    const configuracoes = {};

    // Identifica as linhas que são cabeçalhos de lista
    const cabecalhosListas = ["CATEGORIAS DE PROBLEMAS", "TIPOS DE EQUIPAMENTOS", "NÍVEIS DE URGÊNCIA", "ITENS DO CHECKLIST"];
    const linhasCabecalhoLista = new Set();
    for (let i = 0; i < dados.length; i++) {
        const chave = String(dados[i][0]).trim().toUpperCase();
        if (cabecalhosListas.some(cab => chave === cab.toUpperCase())) {
            linhasCabecalhoLista.add(i); // Adiciona o índice (base 0) da linha do cabeçalho
        }
    }

    let lendoLista = false; // Flag para saber se estamos dentro de uma lista vertical

    for (let i = 0; i < dados.length; i++) {
        const chave = String(dados[i][0]).trim();
        const valor = dados[i][1]; // Valor da coluna B

        if (linhasCabecalhoLista.has(i)) {
            // É um cabeçalho de lista, ativa a flag e ignora esta linha como config simples
            lendoLista = true;
            continue; // Pula para a próxima linha
        }

        // Se a chave for vazia, encerra a leitura da lista (se estiver lendo uma)
        if (chave === "") {
            lendoLista = false;
            continue;
        }

        // Se NÃO estamos lendo uma lista, e a chave não é vazia, considera como configuração simples
        if (!lendoLista && chave !== "") {
             // Formata datas se necessário
            if (valor instanceof Date && !isNaN(valor.getTime())) {
                 // Ex: DATA_CRIACAO_SCRIPT
                 configuracoes[chave] = valor.toISOString();
            } else {
                 configuracoes[chave] = valor !== undefined && valor !== null ? String(valor) : ""; // Converte para string
            }
        }
        // Se lendoLista é true e chave não é vazia, ignora (é um item da lista)
    }
    // Logger.log("Configurações lidas (simples): " + JSON.stringify(configuracoes));
    return { success: true, configuracoes: configuracoes };

  } catch (e) {
    Logger.log(`Erro em obterConfiguracoes: ${e.message}\n${e.stack}`);
    return { success: false, message: "Erro ao obter configurações: " + e.message };
  }
}


/** Salva uma configuração específica (chave/valor) na aba 'Configurações'. */
function salvarConfiguracao(chave, valor) {
  var lock = LockService.getScriptLock();
  var lockAcquired = lock.tryLock(10000); // Lock curto para escrita simples
   if (!lockAcquired) {
      Logger.log("salvarConfiguracao: Lock não adquirido.");
      return { success: false, message: "Servidor ocupado, tente salvar a configuração novamente." };
   }

  try {
    if (!chave || typeof chave !== 'string' || chave.trim() === '') {
        return { success: false, message: "Chave de configuração inválida ou não informada." };
    }
    chave = chave.trim(); // Garante que não há espaços extras
    // Chaves que não devem ser alteradas por esta função (gerenciadas internamente)
    const chavesProtegidas = ['ID_PLANILHA', 'DATA_CRIACAO_SCRIPT', 'VERSAO_SCRIPT', 'PASTA_IMAGENS'];
     // Verifica se a chave (ignorando case) está na lista de protegidas
    if (chavesProtegidas.some(p => p.toUpperCase() === chave.toUpperCase())) {
         return { success: false, message: `A configuração '${chave}' é gerenciada internamente e não pode ser alterada aqui.` };
    }
    // Chaves que representam listas verticais também não devem ser alteradas aqui
    const cabecalhosListas = ["CATEGORIAS DE PROBLEMAS", "TIPOS DE EQUIPAMENTOS", "NÍVEIS DE URGÊNCIA", "ITENS DO CHECKLIST"];
     if (cabecalhosListas.some(l => l.toUpperCase() === chave.toUpperCase())) {
        return { success: false, message: `A configuração '${chave}' representa uma lista vertical e não pode ser alterada aqui. Edite os itens diretamente na planilha.` };
    }


    const plan = obterPlanilha();
    const abaCfg = plan.getSheetByName(NOME_PLANILHA_CONFIGURACOES);

    if (!abaCfg) {
        return { success: false, message: `Aba '${NOME_PLANILHA_CONFIGURACOES}' não encontrada.` };
    }

    // Procura a chave na coluna A
    const chavesColunaA = abaCfg.getRange("A1:A" + abaCfg.getLastRow()).getValues();
    let linhaEncontrada = -1;

    for (let i = 0; i < chavesColunaA.length; i++) {
      // Comparação case-insensitive
      if (String(chavesColunaA[i][0]).trim().toUpperCase() === chave.toUpperCase()) {
        linhaEncontrada = i + 1; // Linha base 1
        break;
      }
    }

    // Atualiza ou adiciona a chave/valor
    if (linhaEncontrada > 0) {
      // Verifica se esta linha não é um cabeçalho de lista (segurança extra)
       if (cabecalhosListas.some(l => l.toUpperCase() === String(chavesColunaA[linhaEncontrada-1][0]).trim().toUpperCase())) {
            return { success: false, message: `Tentativa de sobrescrever valor para cabeçalho de lista '${chave}'. Operação não permitida.` };
       }
      // Atualiza o valor na coluna B da linha encontrada
      abaCfg.getRange(linhaEncontrada, 2).setValue(valor);
      Logger.log(`Configuração '${chave}' atualizada para '${valor}' na linha ${linhaEncontrada}.`);
    } else {
      // Adiciona a nova chave/valor ao final da aba
       Logger.log(`Chave '${chave}' não encontrada. Adicionando ao final da aba Configurações.`);
       const lastRow = abaCfg.getLastRow();
       abaCfg.getRange(lastRow + 1, 1).setValue(chave).setTextStyle(SpreadsheetApp.newTextStyle().setBold(true).build()); // Chave em negrito
       abaCfg.getRange(lastRow + 1, 2).setValue(valor);
       Logger.log(`Configuração '${chave}' adicionada na linha ${lastRow + 1}.`);

       // Se adicionou INTEGRAÇÃO_AUTOMATICA, aplicar validação
        if (chave.toUpperCase() === 'INTEGRACAO_AUTOMATICA') {
             const cellIntegracao = abaCfg.getRange(lastRow + 1, 2);
             const ruleIntegracao = SpreadsheetApp.newDataValidation().requireValueInList(['SIM', 'NAO'], true).setAllowInvalid(false).build();
             cellIntegracao.setDataValidation(ruleIntegracao);
             Logger.log("Validação SIM/NAO aplicada na nova célula de Integração Automática.");
        }
    }

    SpreadsheetApp.flush(); // Garante que a escrita foi feita

     // Se a configuração alterada foi a de integração, reconfigura os gatilhos
     if (chave.toUpperCase() === 'INTEGRACAO_AUTOMATICA') {
         Logger.log("Configuração de integração alterada. Reconfigurando gatilhos...");
         configurarGatilhoAutomatico(); // Chama a função para atualizar os triggers
     }


    return { success: true, message: `Configuração '${chave}' salva com sucesso.` };

  } catch (e) {
    Logger.log(`Erro em salvarConfiguracao para chave '${chave}': ${e.message}\n${e.stack}`);
    return { success: false, message: `Erro ao salvar configuração '${chave}': ${e.message}` };
  } finally {
     if (lockAcquired) {
        lock.releaseLock();
     }
  }
}


/** Obtém configurações gerais (chave/valor simples) e a versão do app. */
function obterConfiguracoesGerais() {
  try {
    const configResult = obterConfiguracoes(); // Usa a função que já lê chave/valor
    return {
      success: true,
      versaoApp: VERSAO_APP,
      configuracoes: configResult.success ? configResult.configuracoes : {} // Retorna as configs lidas
    };
  } catch (e) {
    Logger.log("Erro em obterConfiguracoesGerais: " + e.message);
    return { success: false, message: "Erro ao obter configurações gerais: " + e.message };
  }
}

/** Obtém apenas a versão do App. */
function obterVersaoApp() {
  // Simplesmente retorna a variável global
  return { success: true, versao: VERSAO_APP };
}

// ========================================================================
// Funções Utilitárias
// ========================================================================

/**
 * Gera um ID único para novas manutenções.
 * Formato: 'M' + Timestamp em base36 + Parte aleatória em base36.
 * @returns {string} ID único.
 */
function gerarId() {
  // Timestamp atual em milissegundos, convertido para base 36 (usa 0-9 e a-z)
  const timestampPart = Date.now().toString(36);
  // Número aleatório entre 0 e 1, convertido para base 36, pegando uma parte do meio para mais aleatoriedade
  const randomPart = Math.random().toString(36).substring(2, 9); // Pega 7 caracteres aleatórios
  const newId = 'M' + timestampPart + randomPart;
  // Logger.log("Novo ID gerado: " + newId);
  return newId;
}


/**
 * Formata um objeto Date ou uma string/número de data reconhecível para o formato DD/MM/YYYY HH:MM.
 * @param {Date|string|number} data A data a ser formatada.
 * @returns {string} A data formatada ou uma string indicando erro/N/A.
 */
function formatarData(data) {
  if (data === null || data === undefined || data === '') {
    return 'N/A'; // Retorna N/A para valores vazios ou nulos
  }

  try {
    let dataObj;

    // Tenta converter para Date se não for
    if (data instanceof Date && !isNaN(data.getTime())) {
      dataObj = data; // Já é um Date válido
    } else if (typeof data === 'string') {
        // Tenta converter ISO String primeiro (mais confiável)
        if (data.includes('T') && data.includes('Z')) {
             dataObj = new Date(data);
        } else {
             // Tenta outros formatos, incluindo DD/MM/YYYY
            dataObj = new Date(data);
             // Se falhou com new Date direto, tenta DD/MM/YYYY
            if (isNaN(dataObj.getTime())) {
                const parts = data.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})(?:[ T](\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?$/);
                if (parts) {
                    // Assume DD/MM/YYYY
                    dataObj = new Date(parts[3], parseInt(parts[2], 10) - 1, parts[1], parts[4] || 0, parts[5] || 0, parts[6] || 0);
                } else {
                    // Tenta YYYY-MM-DD
                    const partsIso = data.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})(?:[ T](\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?$/);
                     if (partsIso) {
                        dataObj = new Date(partsIso[1], parseInt(partsIso[2], 10) - 1, partsIso[3], partsIso[4] || 0, partsIso[5] || 0, partsIso[6] || 0);
                     } else {
                       dataObj = new Date(NaN); // Marca como inválido se nenhum formato funcionou
                     }
                }
            }
        }
    } else if (typeof data === 'number') {
        // Assume que é um timestamp Unix em milissegundos
        dataObj = new Date(data);
    } else {
        // Tipo desconhecido
        return 'Tipo Inválido';
    }

    // Verifica se a conversão resultou em uma data válida
    if (isNaN(dataObj.getTime())) {
        // Logger.log(`Formato de data inválido ou não reconhecido: ${data}`);
        return 'Data Inválida';
    }

    // Formata a data válida usando Utilities.formatDate e o fuso horário do script
    return Utilities.formatDate(dataObj, Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm');

  } catch (e) {
    Logger.log(`Erro inesperado em formatarData para valor [${data}]: ${e.message}`);
    return 'Erro Data'; // Retorna erro genérico
  }
}

// ========================================================================
// Função para Auxiliar na Depuração
// ========================================================================
/**
 * Função simples para testar se o script está respondendo.
 * Chame via GET: [URL_DO_SCRIPT]?action=ping
 * @returns {object} Objeto JSON simples de confirmação.
 */
function ping() {
  const timestamp = new Date();
  Logger.log(`Ping recebido em: ${timestamp.toISOString()}`);
  return {
    success: true,
    message: "Pong! O servidor está respondendo.",
    versao: VERSAO_APP,
    timestamp: timestamp.toISOString(),
    timezone: Session.getScriptTimeZone()
  };
}

// ========================================================================
// FIM DO SCRIPT
// ========================================================================
